<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Javase | Yw</title><meta name="keywords" content="yw,Yw"><meta name="author" content="Yw"><meta name="copyright" content="Yw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是我学习Java时候做的笔记，比较水。"><meta property="og:type" content="article"><meta property="og:title" content="Javase"><meta property="og:url" content="https://yww52.com/2020/06/17/Javase/index.html"><meta property="og:site_name" content="Yw"><meta property="og:description" content="这是我学习Java时候做的笔记，比较水。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.yww52.com/2020/6/2020-6-18top_img.jpg"><meta property="article:published_time" content="2020-06-17T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-31T21:05:59.212Z"><meta property="article:author" content="Yw"><meta property="article:tag" content="yw,Yw"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.yww52.com/2020/6/2020-6-18top_img.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/jaslli/HexoFile1@latest/icon.ico"><link rel="canonical" href="https://yww52.com/2020/06/17/Javase/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Javase",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-01-01 05:05:59"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.yww52.com/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont iconfaxian-copy"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont iconbumenguidangtongji"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont iconfenlei"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont iconlianjie"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont iconaixin"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img.yww52.com/2020/6/2020-6-18top_img.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yw</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont iconfaxian-copy"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont iconbumenguidangtongji"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont iconfenlei"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont iconlianjie"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont iconaixin"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Javase</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-17T16:00:00.000Z" title="发表于 2020-06-18 00:00:00">2020-06-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-31T21:05:59.212Z" title="更新于 2023-01-01 05:05:59">2023-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Javase"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​ 以前都是记笔记，每篇文章都很短而且很乱，现在学完很久了，有些东西都快忘了，最近又刚刚整完主题，所以索性就整理一下前面的文章，顺便整合起来复习一下。</p><div class="tip success"><p>这是我学习JavaSE的时候记的笔记，文章较长，建议目录直接跳转</p><p></p></div><h2 id="什么是JavaSE"><a href="#什么是JavaSE" class="headerlink" title="什么是JavaSE"></a>什么是JavaSE</h2><p>​ 复习前先来看看什么是JavaSE，来看看百度百科是怎么描述的。（大概了解一下就好了）</p><blockquote><p>Java SE（Java Standard Edition，Java 标准版）是Java技术的核心和基础，是Java ME和Java EE编程的基础 [1] 。Java SE是由Sun Microsystems公司于1995年5月推出的Java程序设计语言和Java平台的总称。</p></blockquote><h2 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h2><p>学习Java的第一件事情就是要先配置好Java所需要的环境，不然运行不了还怎么学习。</p><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>JDK是Java语言的软件开发工具包，是整个Java开发的核心，它包含了Java的运行环境和Java工具，所以这个是必须要下载的。</p><div class="note info flat"><p>下载的版本就选Java8好了，不一定最新的就是最好的，当然最新的也可以。至于IDE嘛，喜欢哪个用哪个，我用的就是idea</p></div><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><ol><li><p>此电脑，右键，点击“属性”，点击“高级系统设置”，点击“高级”下的环境变量，配置下面三个变量，有就添加变量，没有就新建变量</p></li><li><p>分别配置好以下三个环境变量</p><ul><li><p>JAVA_HOME<br>路径就填JDK的安装路径</p></li><li><p>PATH<br>路径填JDK命令文件的位置，即bin目录的位置</p></li><li><p>CLASSPATH</p><p>开头输入<strong>“.;”</strong>,然后填lib目录的位置</p></li></ul></li></ol><h3 id="检查是否配置成功"><a href="#检查是否配置成功" class="headerlink" title="检查是否配置成功"></a>检查是否配置成功</h3><p>配置完了之后就去检查一下有没有配置成功吧，以免之后出错。去cmd输入命令java-version，若有版本号出现就证明配置成功了。</p><h2 id="省略一部分"><a href="#省略一部分" class="headerlink" title="省略一部分"></a>省略一部分</h2><p>时间不允许我写这么多了，所以我就跳过了一些基本知识，之后我在补（如果有机会的话）。</p><ul><li>操作符</li><li>变量和常量</li><li>控制流程语句（for,if,while）</li></ul><blockquote><p>这些是跟很多编程语言都是一样的，特别是和C,C++，所以我省了</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法也就是C语言里面的函数，也就是一段实现特定效果的语段。main方法就是主方法，程序的入口。</p><h3 id="方法的简单使用"><a href="#方法的简单使用" class="headerlink" title="方法的简单使用"></a>方法的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法调用，若方法没加static修饰，就new一个Hello的对象，然后调用这个方法</span></span><br><span class="line">        helloworld();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//定义，修饰符，返回值加方法名，方法体</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helloworld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载就在于方法名是一样的，参数列表不一样。</p><div class="note warning flat"><p>重载不是重写，这是两个概念，不要弄混了</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        helloworld();</span><br><span class="line">        helloworld(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helloworld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helloworld</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h3><p>递归的思想就是自己调用自己（套娃），比如下面这个求阶乘的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fnc(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fnc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>)</span><br><span class="line">         res = res * fnc(i - <span class="number">1</span>);<span class="comment">//套娃</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>成天都说Java是面向对象的语言。那什么是面向对象编程呢？</p><blockquote><p>面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式</p></blockquote><p>大概了解一下就好了，Java是离不开类和对象的，所以之后就会感受到什么是面向对象编程。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类就是一个抽象的概念，对象就是从类里实例化出来的个体。之后的Java学习都要用到。现在就来定义一个简单的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意一个类文件里面只能有一个public类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类属性和类方法"><a href="#类属性和类方法" class="headerlink" title="类属性和类方法"></a>类属性和类方法</h3><p>上述的i和print()就本别是类属性和类方法。把类当作是一个整体，类属性就相当于是一个部件，类方法相当于部件实现的功能。</p><blockquote><p>类属性和方法调用必须通过对象，比如demo类有个test对象，那就是test.i和test.print()</p></blockquote><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>上述类，属性，对象都用public来修饰，public就是一个访问修饰符，访问修饰符是来设定权限的，设定谁才能使用这个类，以下是四种Java的访问权限。</p><table><thead><tr><th align="center">访问级别</th><th align="center">访问修饰符</th><th align="center">同类</th><th align="center">同包不同类(不含子类)</th><th align="center">同包子类</th><th align="center">不同的包(不含子类)</th><th align="center">不同包子类</th></tr></thead><tbody><tr><td align="center">公开的</td><td align="center">public</td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td></tr><tr><td align="center">受保护的</td><td align="center">protected</td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"></td><td align="center"><strong>√</strong></td></tr><tr><td align="center">默认的</td><td align="center">什么都不加</td><td align="center"><strong>√</strong></td><td align="center"><strong>√</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center"><strong>√</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。</p><p>听起来很绕，写起来就知道什么意思了。</p><p>使用类就要创建这个类的对象。就比如new demo()。但也只是创建对象，无法访问到它，所以就用引用来代表这个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用了d这个变量来代表新创建的demo对象</span></span><br><span class="line">		demo d = <span class="keyword">new</span> demo();</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>类还有一个很重要的概念就是构造方法，也叫构造器。构造方法使用来创建类的，所以方法名与类名一模一样，没有返回值，如果要实例化对象，就一定会用到构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	demo d1 = <span class="keyword">new</span> demo();</span><br><span class="line">        demo d2 = <span class="keyword">new</span> demo(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    demo()&#123;</span><br><span class="line">    	i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//有参构造函数（重载）</span></span><br><span class="line">    demo(<span class="keyword">int</span> t )&#123;</span><br><span class="line">       i = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，系统会默认提供无参的构造方法，所以你能使用new demo()来创建对象，但如果定义了有参的构造方法，无参的就会没了，所以就不能使用new demo()来创建对象，所以养成个好习惯，创建类的时候，顺便写上无参的构造方法。</p></blockquote><h3 id="Java的三大特性"><a href="#Java的三大特性" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><div class="note info flat"><p>关键字extends</p></div><p>子类继承父类的所有方法和属性，Java的继承包括两种：</p><ol><li>类的单继承，即只能继承一个父类</li><li>接口的多继承，一个类可以实现（继承）多个接口</li></ol><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><div class="note info flat"><p>关键字就是private,protected,public</p></div><p>封装就是将一个类里的属性和方法包装起来，严格控制访问权限。就比如JavaBean就是一个标准的封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态就是同一个行为具有多个不同表现形式或形态的能力。实现多态的三个必要条件有</p><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ol><p>可以先看个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      show(<span class="keyword">new</span> Cat());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> Dog());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      Animal a = <span class="keyword">new</span> Cat();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      Cat c = (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal a)</span>  </span>&#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this与super关键字"><a href="#this与super关键字" class="headerlink" title="this与super关键字"></a>this与super关键字</h3><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>this的本质是”创建好的对象的地址“，经常用为当前对象。下面举个例子来说明this的使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>（<span class="title">int</span> <span class="title">a</span>,<span class="title">int</span> <span class="title">b</span>） </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = a;           		<span class="comment">//this.a指的是这个对象中定义的a，与构造器定义的区分</span></span><br><span class="line">	<span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="title">int</span> <span class="title">a</span>,<span class="title">int</span> <span class="title">b</span>,<span class="title">int</span> <span class="title">c</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(a,b);          	 	<span class="comment">// 引用同个类的构造器，必须放在第一行，不能引用两个</span></span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">this</span>.a();					<span class="comment">//通过this来调用本类的方法</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>使用this关键字来调用重载的构造方法时，可以避免相同的初始化代码，但只能在构造方法中使用，而且须位于构造方法的第一句。</p></div><blockquote><p>this不能用于static方法中。因为static方法是属于类的，this是代表对象，具体详情可以参考下面关于static的描述</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>super可以理解为指向父类对象（离得最近的）的一个指针，使用方法也有三种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> id;</span><br><span class="line">    demo()&#123;</span><br><span class="line">        id = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo_01</span> <span class="keyword">extends</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    demo_01()&#123;</span><br><span class="line">        <span class="keyword">super</span>();					<span class="comment">//1.引父类的无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="keyword">super</span>.id;				<span class="comment">//2. 调用父类的成员</span></span><br><span class="line">        <span class="keyword">super</span>.print();				<span class="comment">//3. 调用父类的方法，跟第二个使用很像</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><ul><li>子类的构造函数中要调用super()，一定要放在首行，即使不用系统也会自行调用super()，即子类调用自己的构造器时会先调用父类的，先创建一个父类的对象</li><li>super是从子类中调用父类的方法或变量，而this为在同一类中调用其它方法或变量</li><li>从本质上来讲this是一个指向本对象的指针，而super是一个Java的关键字</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个固定长度的，包含了相同类型数据的容器。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先使用这种方法声明</span></span><br><span class="line">datatype[] arr_name;</span><br><span class="line"><span class="comment">// 这种是C/C++风格的声明，不推荐</span></span><br><span class="line">datatype  arr_name[];</span><br></pre></td></tr></table></figure><h4 id="数组的实例"><a href="#数组的实例" class="headerlink" title="数组的实例"></a>数组的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先使用这种方法实例</span></span><br><span class="line">datatype[] arr;</span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">datatype arr[];</span><br></pre></td></tr></table></figure><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dataType[] arr_name = new dataType[arraysize];</span></span><br><span class="line">		<span class="keyword">int</span> arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h4 id="三种初始化方式"><a href="#三种初始化方式" class="headerlink" title="三种初始化方式"></a>三种初始化方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.静态初始化</span></span><br><span class="line">   type[]  arr_name=&#123;,,,&#125;</span><br><span class="line"><span class="comment">//2. 默认初始化</span></span><br><span class="line">   type[]  arr_name = <span class="keyword">new</span> type[<span class="keyword">int</span>]    <span class="comment">//全初始化为默认值，Boolean为false，引用类型为为null</span></span><br><span class="line"><span class="comment">//3.动态初始化</span></span><br><span class="line">   <span class="comment">//先分配空间，然后一个个初始化</span></span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组可以理解为一个数组，这个数组存着几个一维数组,所以Java的数组可以是不规则的。</p><h4 id="二维数组创建："><a href="#二维数组创建：" class="headerlink" title="二维数组创建："></a>二维数组创建：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[][] arr_name= <span class="keyword">new</span> type[<span class="keyword">int</span>][<span class="keyword">int</span>];</span><br></pre></td></tr></table></figure><h4 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.静态初始化</span></span><br><span class="line">		type[][] arr_name =&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</span><br><span class="line"><span class="comment">//2.动态初始化，可以使数组不规则</span></span><br><span class="line">		 arr_name[<span class="number">0</span>]=<span class="keyword">new</span> type[]&#123;,,,&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口时一个抽象的类型，跟抽象类有着差不多作用，但又不是类，相当于一个模板需要我们去完善，实现功能，所以接口是不能被实例化的，使用它就需要继承它来实现。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种特殊的类，它的作用就是给子类提供了模板，<strong>它不能被实例化</strong>，所以抽象类是被当作父类去继承的。说到抽象类，就先聊聊什么是抽象类。类里有抽象方法的类被叫为抽象类，但要注意抽象类不是一定有抽象方法。</p><blockquote><p>定义抽象类就用关键字abstract，将类声明为抽象类</p></blockquote><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>有抽象方法的类被叫为抽象类，那什么是抽象方法呢，就是专门给我们去继承实现的方法。所以抽象方法是必须要被重写的，而且继承了该抽象类就必须重写抽象方法，不然系统会编译出错。</p><blockquote><p>抽象方法的定义也是用关键字abstract，抽象方法是必须被重写的，所以它是不需要方法体的。</p></blockquote><div class="note warning flat"><p>子类继承了抽象类，没重写其抽象方法子类就必须在声明为抽象类，还有的就是构造方法和用static修饰的类方法是不能被声明为抽象方法的。</p></div><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>大致了解了抽象类和抽象方法就能理解接口是什么了吧。接口时抽象方法的集合，虽然也可以定义变量，但最好不要破坏了接口的特性，全是抽象方法就好了。</p><blockquote><p>接口是用关键字interface来定义的，类通过关键字implements去实现接口，而且里面的方法是不能有抽象方法的，继承的类必须重写里面所有的抽象方法。</p></blockquote><p>这是一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> <span class="keyword">implements</span> <span class="title">demotest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        demo d = <span class="keyword">new</span> demo();</span><br><span class="line">        d.a();</span><br><span class="line">        d.b();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demotest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><p>在知道了接口之后，就会有个疑问，既然有了抽象类的概念，为什么还要特意设计接口呢？这就要涉及到接口的一个特点了。</p><blockquote><p>类是只支持单继承，而接口支持多继承。</p></blockquote><p>人们在写程序的时候发现，在继承了一个类之后，人们就不能继续继承了，有些功能又要重新定义和实现，因为Java不想我们弄得很乱，不能像C++那样可以支持继承多个类，所以设计了接口来解决这种问题。可以通过下面的列子来大概了解接口的魅力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了demoA的方法，又继承了demoB的方法，如果还想添加功能可以再写接口在实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> <span class="keyword">implements</span> <span class="title">demoA</span>,<span class="title">demoB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo d = <span class="keyword">new</span> demo();</span><br><span class="line">        d.a();</span><br><span class="line">        d.b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demoA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demoB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>接口的每个方法都会被隐式的指定public abstract来修饰，变量会被隐式的指定 public static final修饰。</p><p>JDK8之后，接口也可以有方法体和静态方法了，但怎么说呢，在我看来还是不加的好</p></div><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = sc.next();</span><br><span class="line"><span class="comment">//        next方法只读去空格之前的数据，并且指向本行</span></span><br><span class="line">        String str2 = sc.nextLine();</span><br><span class="line"><span class="comment">//        nextLine方法可以扫描到一行内容并作为一个字符串而被获取到</span></span><br><span class="line">        <span class="keyword">int</span> i  = sc.nextInt();</span><br><span class="line"><span class="comment">//        nextInt方法只读取数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="System-in和System-out"><a href="#System-in和System-out" class="headerlink" title="System.in和System.out"></a>System.in和System.out</h3><ul><li><p>该方法只能从键盘获取一个字符，而且获取的是char类型的，其他类型的难处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符：&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = (<span class="keyword">char</span>) System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InputStreamReader和BufferedReader"><a href="#InputStreamReader和BufferedReader" class="headerlink" title="InputStreamReader和BufferedReader"></a>InputStreamReader和BufferedReader</h3></li><li><p>可以获取字符串，但是获得int,float等类型需要转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">        InputStreamReader is = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String msg =br.readLine();</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2></li></ul><p>在Java中，有个很重要的类-String类，注意S是大写，就是我们所说的字符串类，这使得我们使用字符串十分方便。</p><h3 id="String的简单应用"><a href="#String的简单应用" class="headerlink" title="String的简单应用"></a>String的简单应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">        System.out.println(str1+str2);</span><br><span class="line">        String str3 = str1+str2;</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip warning"><p>注意String创建了就是不可改变的。</p><p></p></div><p>既然字符串是不可变的，那为什么会出现下面的操作呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;hello&quot;;</span><br><span class="line">        String str2 &#x3D; &quot;world!&quot;;</span><br><span class="line">        String str3 &#x3D; str1+str2;</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">        str1 &#x3D; &quot;hello world!&quot;;</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有人会好奇str1为什么还能继续赋值呢。其实说字符串不可变，是说字符串本身不可变，即“hello”等字符串不能改变，str1只是一个引用，继续赋值只是换了一个地址索引，原来的“hello”还是会存在内存中。</p></blockquote><h3 id="类里经常使用的方法"><a href="#类里经常使用的方法" class="headerlink" title="类里经常使用的方法"></a>类里经常使用的方法</h3><p>都是经常使用的一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 char指定索引处的值</span></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将此字符串与指定对象进行比较</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//使用平台的默认字符集将此 String编码为字节序列，将结果存储到新的字节数组中 </span></span></span><br><span class="line"><span class="function">	<span class="keyword">byte</span>[] <span class="title">getBytes</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回指定字符第一次出现的字符串内的索引 </span></span></span><br><span class="line"><span class="function">	<span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回 true如果，且仅当 length()为0 </span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">//返回此字符串的长度</span></span></span><br><span class="line"><span class="function">	<span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">//将此字符串转换为新的字符数组。 </span></span></span><br><span class="line"><span class="function">	<span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span>  </span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是导致程序中断的事件，它不是算是错误，错误error是值jvm运行你的Java程序出的问题。</p><blockquote><p>Exception类是所有异常类的父类</p></blockquote><h3 id="RuntimeException-运行时异常"><a href="#RuntimeException-运行时异常" class="headerlink" title="RuntimeException(运行时异常)"></a>RuntimeException(运行时异常)</h3><ul><li>ArithmeticException 试图除以0异常</li><li>NullpointerException 空指针异常</li><li>ClassCastException 强制转换异常（引用数据类型转换）</li><li>ArraylndexOutOfBoundsException 数组索引越界异常</li><li>NumberFormatException 数字格式化异常</li></ul><h3 id="CheckedException-已检查异常"><a href="#CheckedException-已检查异常" class="headerlink" title="CheckedException(已检查异常)"></a>CheckedException(已检查异常)</h3><p>这类异常在编译时必须处理，否则无法通过编译</p><h3 id="处理异常的方法"><a href="#处理异常的方法" class="headerlink" title="处理异常的方法"></a>处理异常的方法</h3><ol><li><p>用try-catch-finally来捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>						<span class="comment">//try来捕获异常</span></span><br><span class="line">        &#123;	</span><br><span class="line">            System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)		<span class="comment">//catch来处理异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">            e.printStackTrace( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>					<span class="comment">//finally是必须执行的语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throws抛出异常让系统解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型即参数化类型，本质为数据类型的参数化 ,也就是说所操作的数据类型被指定为一个参数的方式传递，类似于方法中的变量参数。可以用在类、接口、方法的创建中，分别简称为泛型类、泛型接口、泛型方法。</p><h3 id="为什么要使用泛型呢？"><a href="#为什么要使用泛型呢？" class="headerlink" title="为什么要使用泛型呢？"></a>为什么要使用泛型呢？</h3><p>首先举一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">            String item = (String)arrayList.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;元素是&quot;</span> + item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nbsp;运行后就会发现程序崩溃了，这是因为在ArrayList中加入了Integer和String类型的数据，转换就出现了异常，所以为了解决一些集合内的类型转换的问题，就出现了泛型，泛型的使用可以减少类型转换和转换异常的情况。</p><h3 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h3><ol><li>泛型只在编译阶段有效，编译后程序会采取去泛型化的措施，泛型是不会进入到运行阶段的</li><li>泛型类型在逻辑上可以看成是不同的类型，实际上都是相同的基本类型</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>泛型有三种使用方式，泛型类，泛型接口，泛型方法。</p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>&nbsp;首先学容器之前还是学习一下Collection接口，毕竟List与Set接口都是继承的Collection的，所以List与Set都有它的方法，别与Collections类弄混了，前者是集合类的上层接口，后者是一个集合框架的帮助类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	先新建两个Collection</span></span><br><span class="line">	Collection&lt;String&gt;  c1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Collection&lt;String&gt;  c2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 	size()，返回值是int，返回当前集合元素的个数</span></span><br><span class="line">	System.out.println(c1.size());</span><br><span class="line"><span class="comment">//	isEmpty()，返回值是Boolean类型，如果集合是空的就返回true，反之返回false</span></span><br><span class="line">	System.out.println(c1.isEmpty());</span><br><span class="line"><span class="comment">//	add()，向集合里加入元素</span></span><br><span class="line">	c1.add(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//	remove()，移除集合中的元素，并不是删除</span></span><br><span class="line">	c1.remove(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//	clear()，移除所有的元素</span></span><br><span class="line">	c1.clear();</span><br><span class="line"><span class="comment">//	toArray()，转换一个Object数组</span></span><br><span class="line">	Object[] objs = c1.toArray();</span><br><span class="line"><span class="comment">//	contains()，返回值为Boolean类型，判断元素是否在集合内</span></span><br><span class="line">	System.out.println(c1.contains(<span class="string">&quot;student&quot;</span>));</span><br><span class="line"><span class="comment">//	containsAll()，返回值为Boolean类型,判断集c1是否包含有c2的所有元素</span></span><br><span class="line">	c1.containsAll(c2);</span><br><span class="line"><span class="comment">//	addAll()，将c2的所有元素加入c1中</span></span><br><span class="line">	c1.addAll(c2);</span><br><span class="line"><span class="comment">//	removeAll(),移除c1与c2共同的元素(移除c1与c2的交集)</span></span><br><span class="line">	c1.removeAll(c2);</span><br><span class="line"><span class="comment">//	retainAll()，只保留c1与c2共同的元素(移除c1与c2非交集的元素)</span></span><br><span class="line">	c1.retainAll(c2);</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>List是有序，可重复的容器，List接口继承了Collection,因为是有序的，所以List是有索引位置的，因此相对与Collection接口，会有一些 特殊的关于索引位置的方法</p><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul><li><p><strong>LinkedList</strong></p><p>&nbsp;&nbsp;LinkedList底层用双向链表实现的储存。查询效率低，删减效率高，线程不安全</p></li><li><p><strong>ArrayList</strong></p><p>&nbsp;&nbsp;ArrayList底层是用数组实现的储存。查询效率高，增删效率低，线程不安全</p></li><li><p><strong>Vector</strong></p><p>&nbsp;&nbsp;Vector底层是用数组实现的List,相关的方法都加了同步检查，故线程安全,效率低</p></li><li><p>当需要线程安全时就用Vector实现类。查找多就用ArrayList实现类，增删多就用LinkList。</p></li></ul><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// List重载了一个add()方法,在指定索引位置插入一个元素</span></span><br><span class="line">	list.add(<span class="number">3</span>，<span class="string">&quot;sss&quot;</span>);	</span><br><span class="line"><span class="comment">//List重载了一个remove()方法,移除指定索引位置的元素</span></span><br><span class="line">	list.remove(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//	set()，将指定索引位置元素改为指定元素</span></span><br><span class="line">	list.set(<span class="number">2</span>,<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//	get(),返回指定索引位置的元素</span></span><br><span class="line">	System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//	indexOf()，返回指定元素的第一次的索引位置，若没有，返回-1</span></span><br><span class="line">	System.out.println(list.indexOf(<span class="string">&quot;student&quot;</span>));</span><br><span class="line"><span class="comment">//	lastIndexOf(),返回指定元素的最后一次的索引位置，若没有，返回-1</span></span><br><span class="line">	System.out.println(list.lastIndexOf(<span class="string">&quot;student&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h4><ul><li>List允许加重复的元素</li><li>List允许存在null元素</li><li>List是有索引位置的</li><li>List是支持泛型的，所以尽量使用List时要加泛型</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Map是存储Key与Value的容器，每个key都会对应一个Value值，所以键对象不能重复,如果存放相同的键对象，对应值对象会被新的值对象代替。</p><h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul><li><strong>HashMap</strong></li></ul><p>底层是通过哈希表来实现的。线程不安全，但效率高。允许Key与Value为null。</p><ul><li><p><strong>HashTable</strong></p><p>&nbsp;&nbsp;底层实现与HashMap几乎一样，只是方法添加了synchronized来确保线程同步检查。所以线程安全，但效率低，且不允许Key与Value为null。</p></li><li><p><strong>TreeMap</strong></p><p>&nbsp;&nbsp;底层是通过红黑二叉树来实现的。HashMap效率高于TreeMap,需要排序时才会选择使用TreeMap，即按照Key递增的顺序排序，如果是类排序可以考虑使用comparable接口来实现</p></li></ul><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	 Map&lt;Integer,String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	 Map&lt;Integer,String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//	put()，存放键值对</span></span><br><span class="line">	map1.put(<span class="number">1</span>,<span class="string">&quot;student1&quot;</span>);</span><br><span class="line"><span class="comment">//	get()，通过键对象得到对应的值对象</span></span><br><span class="line">	map1.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//	remove()，删除键对象对应的键值对</span></span><br><span class="line">	map1.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//	containsKey()与containsValue()，判断是否包含键对象或值对象是否存在改容器</span></span><br><span class="line">	map1.containsKey(<span class="number">1</span>);</span><br><span class="line">	map1.containsValue(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line"><span class="comment">//	size()，返回容器中键值对的数量</span></span><br><span class="line">	System.out.println(map1.size());</span><br><span class="line"><span class="comment">//	isEmpty(),判断容器是否为空，返回值为Boolean类型</span></span><br><span class="line">	System.out.println(map1.isEmpty());</span><br><span class="line"><span class="comment">//	putAll(),将map2所有的键值对存放到map1里</span></span><br><span class="line">	map1.putAll(map2);</span><br><span class="line"><span class="comment">//	clear(),清空所有键值对</span></span><br><span class="line">	map1.clear();</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>Set是<strong>无序而且是不可重复的</strong>，与List一样继承Collection接口。即没有索引只能遍历查找，通过equals方法为true的不能放入，即使是NULL也只能有一个。往Set里面加入元素，本质就是把这个元素作为Key加入到内部的Map里，由于Map里的key是不重复的所以Set也不重复</p><h4 id="常用实现类-2"><a href="#常用实现类-2" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul><li><p><strong>HashSet</strong></p><pre><code>底层是采用HashMap实现的，本质是简化版的HashMap，因此查询与增删效率较高。</code></pre></li><li><p><strong>TreeSet</strong></p></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><p>因为Set继承与Collection接口，而且没有新增方法，所以方法与Collection是一样的。</p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>迭代器是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>遍历List容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">//使用list里的iterator方法返回一个迭代器，使用该迭代器的hasNext方法得到下一个对象，进而遍历容器</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;String&gt; iter = list.iterator();iter.hasNext();)&#123;</span><br><span class="line">            String t = iter.next();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历Set容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历Set的方法与遍历List是一样的</span></span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;String&gt; iter = set.iterator();iter.hasNext();)&#123;</span><br><span class="line">            String t = iter.next();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历Map容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;student1&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;student2&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;student3&quot;</span>);</span><br><span class="line"><span class="comment">//通过Map.entrySet使用iterator遍历key和value</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="容器遍历汇总"><a href="#容器遍历汇总" class="headerlink" title="容器遍历汇总"></a>容器遍历汇总</h3></li></ul><h4 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种，用for循环遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size() ; i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 第二种，用迭代器遍历</span></span><br><span class="line">	<span class="keyword">for</span>(Iterator&lt;String&gt; iter = list.iterator();iter.hasNext();)&#123;</span><br><span class="line">            String t = iter.next();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第三种，用增强for循环来遍历</span></span><br><span class="line">	<span class="keyword">for</span>(String s :list)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第四种，用foreach遍历</span></span><br><span class="line">	list.forEach(item -&gt; &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//第五种，用list.stream().forEach</span></span><br><span class="line">	list.stream().forEach(item -&gt; &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//经过测试，第一种是效率最高的，也是最推荐的，接下来是第二种，第三种，第四种，第五种</span></span><br></pre></td></tr></table></figure><h4 id="Set遍历"><a href="#Set遍历" class="headerlink" title="Set遍历"></a>Set遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set的遍历与List大同小异,只是没有用索引遍历</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">//第一种，用迭代器遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;String&gt; iter = set.iterator();iter.hasNext();)&#123;</span><br><span class="line">            String t = iter.next();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第二种，用增强for循环来遍历</span></span><br><span class="line">		<span class="keyword">for</span>(String s :set)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第三种，用foreach遍历</span></span><br><span class="line">		set.forEach(item -&gt; &#123;</span><br><span class="line">             System.out.println(item);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//第四种，用set.stream().forEach </span></span><br><span class="line">        set.stream().forEach(item -&gt; &#123;</span><br><span class="line">                System.out.println(item);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">//效率比较与List的遍历时一样的</span></span><br></pre></td></tr></table></figure><h4 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，用增强for循环遍历</span></span><br><span class="line">	 <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第二种，通过Map.entrySet使用iterator遍历key和value</span></span><br><span class="line">	Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//第三种，这种方法仅遍历，无法在for循环时实现remove等操作  </span></span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt;entry:map.entrySet())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//第四种，只能获取values，不能获取key</span></span><br><span class="line">        <span class="keyword">for</span>(String t:map.values())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;value= &quot;</span>+t);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//一般使用第一种，但因为第一种方法是二次取值，所以效率会比第二第三种都要低</span></span><br></pre></td></tr></table></figure><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>类java.util.Collections提供了对Set,List,Map的辅助方法</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//	sort(),对list容器内的元素从小到大排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"><span class="comment">//	shuffle(),对list容器内的元素随机排序</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"><span class="comment">//	reverse(),对list容器内的元素逆序排序</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line"><span class="comment">//	fill(),用一个指定对象重写容器</span></span><br><span class="line">        Collections.fill(list,<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//	binarySearch(),对于顺序的list容器，采用二分法查找特定对象</span></span><br><span class="line">		 Collections.sort(list);</span><br><span class="line">        Collections.binarySearch(list, <span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><ul><li>根据处理数据的类型不同分为：字符流和字节流</li><li>根据数据流向的不同分为：输入流和输出流</li></ul><h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><ol><li><p><strong>文件字节流</strong>( 数据源为文件)</p><ul><li><p>FileInputStream 通过字节的方式从文件到程序，读取文件</p></li><li><p>FileOutputStream 通过字节的方式从程序到文件，写入文件</p></li></ul></li><li><p><strong>文件字符流</strong>( 数据源为文件)</p><ul><li><p>FileReader 通过字符的方式从文件到程序</p></li><li><p>FileWriter 通过字符的方式从程序到文件</p><blockquote><p>处理的是字符数组 char</p></blockquote></li></ul></li><li><p><strong>字节数组流</strong>(数据源为字节数组对象)</p><ul><li><p>ByteArrayInputStream 通过字节的方式从字节数组到程序</p></li><li><p>ByteArrayOutputStream 拖过字节的方式从程序到字节数组</p></li></ul></li></ol><div class="note warning flat"><p>使用流之后需要释放流，字节数组流不需要释放，系统会自动释放的</p><p>在cry - with -resources 工具类里，在抛出异常的try{}后加入流的声明，则会帮你自动释放资源，比如try(is;os;is1;os2){}</p></div><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><ol><li><p><strong>字节缓冲流：</strong></p><ul><li><p><strong>BufferedInputStream</strong></p></li><li><p><strong>BufferedOutputStream</strong></p></li><li><p>默认是缓存8K，可以自己修改，原理类似于修饰模式。</p></li><li><p>可以提升性能，运输效率，只用关闭外层的流即可，内层会自动关。手动关闭的话要从里往外关闭</p></li></ul></li><li><p><strong>字符缓冲流：</strong></p><ul><li><p><strong>BufferedReader</strong></p><pre><code>readLine()        读取一行文字</code></pre></li><li><p><strong>BufferedWriter</strong></p><pre><code>newLine()            换行符</code></pre></li><li><p>不要用父类引用指向子类对象，不然用不了这些新增方法</p></li></ul></li><li><p><strong>转换流：</strong></p><ul><li><p><strong>InputStreamReader</strong></p></li><li><p><strong>OutputStreamWriter</strong></p></li><li><p>将字节流转为字符流，方便处理（字节流需全文本）</p></li><li><p>能为字节流指定字符集</p></li></ul></li><li><p><strong>数据流：</strong></p><ul><li><p><strong>DataInputStream</strong></p></li><li><p><strong>DataOutputStream</strong></p></li><li><p>保留数据类型，读取的顺序与写出保持一致</p></li><li><p>数据流里放的是InputStream与OutputStream的字节流</p></li></ul></li><li><p><strong>对象流：</strong></p><ul><li><p><strong>ObjectInputStream</strong> 反序列化</p></li><li><p><strong>ObjectOutputStream</strong> 序列化</p></li><li><p>先写出后读取，读取的顺序与写出的顺序保持一致</p></li><li><p>不是所有的对象都能序列化，必须是实现了Serializable接口</p></li><li><p>方法和数据流差不多，多了writeobject和readObject</p></li><li><p>如果不需要序列化某个对象的值，就用transient来修饰类的对象</p></li></ul></li><li><p><strong>打印流：</strong></p><ul><li><p><strong>PrintfStream</strong></p></li><li><p><strong>PrintWriter</strong></p></li></ul></li><li><p><strong>随机访问：</strong></p><ul><li><p><strong>RandomAcessFile</strong></p></li><li><p>两个模式(mode)<br>“r”读 “rw”读写</p></li></ul></li><li><p><strong>合并：</strong></p><ul><li><p><strong>SequenceInputStream</strong></p></li><li><p>先用Vector容器来储存输入流，然后用该容器的elements()方法返回SequenceInputStream的参数，从而合成一个流</p></li></ul></li></ol><h2 id="TCP与UDP的简单实现"><a href="#TCP与UDP的简单实现" class="headerlink" title="TCP与UDP的简单实现"></a>TCP与UDP的简单实现</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li><p>使用基于TCP协议的Socket网络编程</p></li><li><p>TCP协议基于请求- 响应模式</p></li><li><p>利用IO流实现数据的传输</p></li><li><p>TCP使用的基本流程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建服务器</span></span><br><span class="line"><span class="comment"> * 1. 使用ServerSocket创建服务器   需要指定端口</span></span><br><span class="line"><span class="comment"> * 2. 阻塞式的等待连接  accept返回一个socket对象</span></span><br><span class="line"><span class="comment"> * 3. 输入输出流操作	</span></span><br><span class="line"><span class="comment"> * 4. 释放资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Setver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//        1.</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"><span class="comment">//        2.</span></span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;一个客户端建立了连接&quot;</span>);</span><br><span class="line"><span class="comment">//        3.</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">        String data = dis.readUTF();</span><br><span class="line">        System.out.println(data);</span><br><span class="line"><span class="comment">//        4.</span></span><br><span class="line">        dis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建客户端</span></span><br><span class="line"><span class="comment"> * 1. 使用Socket创建客户端   指定服务器的地址和端口</span></span><br><span class="line"><span class="comment"> * 2. 输入输出流操作</span></span><br><span class="line"><span class="comment"> * 3. 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        1.</span></span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>);</span><br><span class="line"><span class="comment">//        2.</span></span><br><span class="line">        DataOutputStream dos =<span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">        String data = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        dos.writeUTF(data);</span><br><span class="line">        dos.flush();</span><br><span class="line"><span class="comment">//        3.</span></span><br><span class="line">        dos.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><p>基于UDP协议的Socket网络编程实现</p></li><li><p>不需要IO流实现数据传输，数据被打包成包裹发送到目的地（注意传输的包裹不要太大）</p></li><li><p>用到的两个类：</p><ol><li>DatagramPacket</li><li>DatagramSocket</li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	    *                      发送端</span></span><br><span class="line"><span class="comment">	    *</span></span><br><span class="line"><span class="comment">	    * 1. 使用DatagramSocket(int port)指定端口,创建发送端</span></span><br><span class="line"><span class="comment">	    * 2. 准备数据(一定要转成字节数组)</span></span><br><span class="line"><span class="comment">	    * 3. 将字节数组封装成DatagramPacket包裹，需要指定目的地</span></span><br><span class="line"><span class="comment">	    * 4. 用send(DatagramPacket p)</span></span><br><span class="line"><span class="comment">	    * 5. 释放资源</span></span><br><span class="line"><span class="comment">	    */</span></span><br><span class="line">	   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Client</span> </span>&#123;</span><br><span class="line">	       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	   <span class="comment">//        1.</span></span><br><span class="line">	           DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//        2.  比如发送一段文字</span></span><br><span class="line">	           String msg = <span class="string">&quot;你好!&quot;</span>;</span><br><span class="line">	           <span class="keyword">byte</span>[] datas = msg.getBytes();</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//        3.  指定的端口要是接收端创建时指定的端口</span></span><br><span class="line">	           DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,</span><br><span class="line">	                   <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">6666</span>));</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//        4.</span></span><br><span class="line">	           client.send(packet);</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//        5.</span></span><br><span class="line">	           client.close();</span><br><span class="line">	   </span><br><span class="line">	       &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	   </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *                 接收端</span></span><br><span class="line"><span class="comment"> *   1. 使用DatagramSocket(int port)指定端口,创建接收端</span></span><br><span class="line"><span class="comment"> *   2. 准备容器，封装成DatagramPacket包裹，用来接收发送端的包裹</span></span><br><span class="line"><span class="comment"> *   3. 用seceive(DatagramPacket p)阻塞式的接收包裹</span></span><br><span class="line"><span class="comment"> *   4. 分析数据，比如用getData()和getLengeth()方法</span></span><br><span class="line"><span class="comment"> *   5. 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//        1.</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2.</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        3.</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        4.</span></span><br><span class="line">        <span class="keyword">byte</span>[] flush = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(flush,<span class="number">0</span>,flush.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        5.</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>笔记丢了，下次在补</p></blockquote><div class="tip success"><p>终于整理完了，暂时不写了，如果想到有些漏的，在加上，还有一些其他的知识，我会用单独的文章来写</p><p></p></div><blockquote><p>笔记有一些是网上的，所以要是有侵犯到你的权益可以通知我删除。</p></blockquote></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img.yww52.com/2020/6/2020-6-18top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/22/IOC/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.yww52.com/2020/6/2020-6-23top_img.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IOC</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/16/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.btstu.cn/sjbz/api.php?lx=dongman&amp;format=images" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博客主题更换</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJavaSE"><span class="toc-number">2.</span> <span class="toc-text">什么是JavaSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">Java环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDJDK"><span class="toc-number">3.1.</span> <span class="toc-text">下载JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">设置环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F"><span class="toc-number">3.3.</span> <span class="toc-text">检查是否配置成功</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">省略一部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">方法的简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92"><span class="toc-number">5.3.</span> <span class="toc-text">方法递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">类属性和类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">7.5.</span> <span class="toc-text">Java的三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.5.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">7.5.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">7.5.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E4%B8%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.6.</span> <span class="toc-text">this与super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-number">7.6.1.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">7.6.2.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.3.</span> <span class="toc-text">两者对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">8.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">8.1.1.</span> <span class="toc-text">数组的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.1.2.</span> <span class="toc-text">数组的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">8.1.3.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">三种初始化方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">8.2.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A"><span class="toc-number">8.2.1.</span> <span class="toc-text">二维数组创建：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.2.2.</span> <span class="toc-text">二维数组的初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">9.3.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">9.4.</span> <span class="toc-text">接口的多继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">Scanner类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-in%E5%92%8CSystem-out"><span class="toc-number">10.1.</span> <span class="toc-text">System.in和System.out</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader%E5%92%8CBufferedReader"><span class="toc-number">10.2.</span> <span class="toc-text">InputStreamReader和BufferedReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">String的简单应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%87%8C%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">类里经常使用的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">12.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RuntimeException-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">12.1.</span> <span class="toc-text">RuntimeException(运行时异常)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CheckedException-%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">12.2.</span> <span class="toc-text">CheckedException(已检查异常)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">处理异常的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">为什么要使用泛型呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">13.2.</span> <span class="toc-text">泛型的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">14.</span> <span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">14.1.</span> <span class="toc-text">Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">14.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">14.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">14.2.2.</span> <span class="toc-text">常用实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95"><span class="toc-number">14.2.3.</span> <span class="toc-text">特殊方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%A6%81%E7%82%B9"><span class="toc-number">14.2.4.</span> <span class="toc-text">一些要点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">14.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">14.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB-1"><span class="toc-number">14.3.2.</span> <span class="toc-text">常用实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.3.</span> <span class="toc-text">常用的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">14.4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">14.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB-2"><span class="toc-number">14.4.2.</span> <span class="toc-text">常用实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.3.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.5.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">14.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">14.5.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%81%8D%E5%8E%86%E6%B1%87%E6%80%BB"><span class="toc-number">14.6.</span> <span class="toc-text">容器遍历汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%81%8D%E5%8E%86"><span class="toc-number">14.6.1.</span> <span class="toc-text">List遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E9%81%8D%E5%8E%86"><span class="toc-number">14.6.2.</span> <span class="toc-text">Set遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E9%81%8D%E5%8E%86"><span class="toc-number">14.6.3.</span> <span class="toc-text">Map遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">14.7.</span> <span class="toc-text">Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">14.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">14.7.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">15.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">15.1.</span> <span class="toc-text">IO流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81"><span class="toc-number">15.2.</span> <span class="toc-text">节点流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">15.3.</span> <span class="toc-text">处理流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">16.</span> <span class="toc-text">TCP与UDP的简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">16.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">16.2.</span> <span class="toc-text">UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">多线程</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By Yw</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referra"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.yww52.com/cdnlogo.png" align="absmiddle" width="59px" height="30px"></a><span>提供加速服务</span><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn"><img class="icp-icon loading" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/icp.png" alt="ICP" data-ll-status="loading"><span>桂ICP备20005765号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://img.yww52.com/other/main.css"><link rel="stylesheet" href="https://img.yww52.com/other/social.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://img.yww52.com/other/tag.css"><link rel="stylesheet" href="https://img.yww52.com/other/iconfont.css"><script async data-pjax src="https://img.yww52.com/other/main.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>