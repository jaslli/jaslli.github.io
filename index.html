<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>yww - debug myself</title><meta name="author" content="yww"><meta name="copyright" content="yww"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="debug myself">
<meta property="og:type" content="website">
<meta property="og:title" content="yww">
<meta property="og:url" content="https://yww52.com/index.html">
<meta property="og:site_name" content="yww">
<meta property="og:description" content="debug myself">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yww52.com/img/butterfly-icon.png">
<meta property="article:author" content="yww">
<meta property="article:tag" content="yw,yww">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yww52.com/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yww52.com/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'yww',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  isShuoshuo: false
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yww</span></a></span><div id="menus"></div></nav><div id="site-info"><h1 id="site-title">yww</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="post_cover left"><a href="/posts/91f4854c" title="Java图片处理"><img class="post-bg" src="https://img.yww52.com/2023/4/2023-4-18top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java图片处理"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/91f4854c" title="Java图片处理">Java图片处理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-04-17T16:00:00.000Z" title="发表于 2023-04-18 00:00:00">2023-04-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">开发环境本次处理图片主要使用的依赖是opencv，具体的方法可以去参照官网。  首先去opencv官网去下载与系统对应的jar包和依赖文件。（这里以windows举例）  选择windows版本opencv-4.7.0-windows.exe，然后进行安装。(linux的版本需要先进行编译后获取动态库和jar包)  在安装目录的opencv/build/java的目录下，获得jar包和动态库文件。（注意是安装目录里）  在maven项目引入opencv依赖。 12345678&lt;!-- OpenCv  --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.opencv&lt;/groupId&gt;    &lt;artifactId&gt;opencv&lt;/artifactId&gt;    &lt;version&gt;4.7.0&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;   ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/58d09dd7" title="开发环境配置"><img class="post-bg" src="https://img.yww52.com/2023/4/2023-4-11top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/58d09dd7" title="开发环境配置">开发环境配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-04-10T16:00:00.000Z" title="发表于 2023-04-11 00:00:00">2023-04-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">环境基于centos7的环境安装。 Java卸载系统自带的JDK查看系统安装的JDK使用rpm -qa | grep jdk命令查看当前系统安装的JDK。 123456[root@192 ~]# rpm -qa | grep jdkjava-1.8.0-openjdk-headless-1.8.0.362.b08-1.el7_9.x86_64java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64java-1.7.0-openjdk-headless-1.7.0.261-2.6.22.2.el7_8.x86_64copy-jdk-configs-3.3-11.el7_9.noarchjava-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64 卸载安装的JDK使用rpm -e --nodeps的命令去卸载上述查询到的JDK。 12345678[root@192 ~]# rpm -e --nodeps...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/4e5ad84e" title="MybatisPlus常用方法"><img class="post-bg" src="https://img.yww52.com/2023/2/2023-2-2top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisPlus常用方法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/4e5ad84e" title="MybatisPlus常用方法">MybatisPlus常用方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-01T16:00:00.000Z" title="发表于 2023-02-02 00:00:00">2023-02-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">简介记录一下常用的一些使用方法。 测试环境表SQL123456789101112131415161718DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (    `id`            CHAR(19)        NOT NULL                        COMMENT &#x27;数据ID&#x27;,  	`username`      VARCHAR(200)    NOT NULL                        COMMENT &#x27;用户名&#x27;,  	`password`      VARCHAR(200)    NOT NULL                        COMMENT &#x27;密码&#x27;,  	`nickname`      VARCHAR(200)    NULL    DEFAULT &#x27;用户昵称&#x27;       COMMENT &#x27;用户昵称&#x27;,  	`avatar`       ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/622a5765" title="2022年度总结"><img class="post-bg" src="https://img.yww52.com/2023/1/2023-1-1/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022年度总结"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/622a5765" title="2022年度总结">2022年度总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">简介​    刚打完游戏，发现2022年已经过去了。正好我这夜猫子也睡不着，就赶着2023年年初，来写了这篇年度总结。  为什么2021年没有写？其实2022年1月1日的时候，我也是刚和朋友打完游戏，也差不多这个点，我已经写了一篇2021年的年度总结，但是后面写完之后，不记得为什么就删掉了，没发出来，所以就没了，也不想重新写了。  这次没有鸽，肯定写出来hh。 生活​    2022年最重要的事应该是我大学毕业了吧。毕业的时候原本想写个大学四年的总结的，后面想想算了，在大学里也没有什么特别的事情，像很多人一样，平平凡凡的上了个大学，平平凡凡的大学毕业。 ​    其实大三大四过得不是很好，成天感觉到很焦虑，我都感觉心理状态有些亚健康了。每天都是上课，考试，刷题，还有那毕设的破事，大学后面两年其实还是有些遗憾的。不过应该也是我太懒了，学习的心情也没有大一大二那两年这么积极了，每天看那两三小时题目，效率也不高，所以后面也没有什么好结果，有些摆烂了。 ​   ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/e31003e0" title="SpringBoot部署启动"><img class="post-bg" src="https://img.yww52.com/2022/09/2022-9-28top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot部署启动"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/e31003e0" title="SpringBoot部署启动">SpringBoot部署启动</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-09-27T16:00:00.000Z" title="发表于 2022-09-28 00:00:00">2022-09-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">前述记录一下比较常用的服务部署方式。 简单粗暴的脚本这种是本地启动的方式，所以需要自行配置服务器的Java环境。 这个是最简单粗暴的方式了，直接使用java -jar命令，修改服务名和运行jar包的位置就可以使用了。 1234567891011121314151617181920#!/bin/bashJAVAHOME=$JAVA_HOMEecho &quot;--------start--------&quot;PID=$(ps -ef|grep app-1.0.0.jar  |grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;)if [ ! $PID ]; then    nohup java -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -Xms512m -Xmn768m -Xmx1024m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC app-1.0.0.jar &gt; app.log...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/b543ced0" title="RabbitMQ"><img class="post-bg" src="https://img.yww52.com/2021/12/2021-12-26top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RabbitMQ"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/b543ced0" title="RabbitMQ">RabbitMQ</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-12-25T16:00:00.000Z" title="发表于 2021-12-26 00:00:00">2021-12-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span></div><div class="content">什么是MQMQ，全称为message...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/96a41905" title="SpringCloud"><img class="post-bg" src="https://img.yww52.com/2021/12/2021-12-17top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/96a41905" title="SpringCloud">SpringCloud</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-12-16T16:00:00.000Z" title="发表于 2021-12-17 00:00:00">2021-12-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="content">服务注册中心Eureka（停更）Eureka是Netflix开发的一个服务发现框架，SpringCloud将它集成在其子项目spring-cloud-netflix中，主要的功能是服务注册和服务发现。 Eureka有两个组件，对应了两个角色。服务中心和服务的客户端。 Eureka Server引入依赖。 1234&lt;dependency&gt;       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;       &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;   &lt;/dependency&gt; 编写配置文件。 123456789101112eureka:  instance:    # eureka服务端的实例名称    hostname: localhost:7001  client:    # false表示不向注册中心注册自己这个微服务   ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/8a8aa27b" title="lambda表达式与Stream流"><img class="post-bg" src="https://img.yww52.com/2021/12/2021-12-6top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lambda表达式与Stream流"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/8a8aa27b" title="lambda表达式与Stream流">lambda表达式与Stream流</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-12-05T16:00:00.000Z" title="发表于 2021-12-06 00:00:00">2021-12-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">Lambda表达式Lambda表达式出现主要是为了简化代码，若某一个接口只有一个抽象方法，就能使用Lambda表达式来进行简化这个接口的实现类。 Lambda表达式的六种情况12345678910111213141516171819202122// 1 无参，无返回值      Runnable r = () -&gt; System.out.println(&quot;1&quot;);      // 2 一个参数，无返回值      Consumer&lt;String&gt; con = (String s) -&gt; &#123;          System.out.println(s);      &#125;;      // 3 数据类型可以省略，编译器有类型推断      Consumer&lt;String&gt; con1 = (s) -&gt; &#123;          System.out.println(s);      &#125;;      // 4 若只需要一个参数，小括号能省略     ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/28877bf" title="异常处理"><img class="post-bg" src="https://img.yww52.com/2021/10/2021-10-10top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="异常处理"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/28877bf" title="异常处理">异常处理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-09T16:00:00.000Z" title="发表于 2021-10-10 00:00:00">2021-10-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">自定义异常类（配合结果类）12345678910111213141516171819202122232425262728/** * @author yww * @since 2021/10/9 **/@Getter@AllArgsConstructorpublic class GlobalException extends RuntimeException &#123;    /**     * 错误码     */    private Integer code = FAILED.getCode();    /**     * 错误信息     */    private final String message;    public GlobalException(String message) &#123;        this.message = message;    &#125;    public GlobalException(ResultCode resultCode) &#123;        this.code =...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/86ff1dad" title="分布式session的解决方案"><img class="post-bg" src="https://img.yww52.com/2021/6/2021-6-10/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式session的解决方案"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/86ff1dad" title="分布式session的解决方案">分布式session的解决方案</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-09T16:00:00.000Z" title="发表于 2021-06-10 00:00:00">2021-06-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="content">session ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/df083c4d" title="MySQL必知必会"><img class="post-bg" src="https://img.yww52.com/2021/6/2021-6-4top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL必知必会"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/df083c4d" title="MySQL必知必会">MySQL必知必会</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-03T16:00:00.000Z" title="发表于 2021-06-04 00:00:00">2021-06-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="content">了解数据库和表连接1mysql -u root -p 选择数据库1USE crashcourse; 了解数据库和表12345678# 显示所有数据库SHOW DATABASES;# 显示一个数据库中的所有表SHOW TABLES;# 显示表中数据的列SHOW COLUMNS FROM customers;DESCRIBE customers;DESC cutomers; 其他一些语句1234567891011# 用于显示服务器状态信息SHOW STATUS;# 显示创建特定数据库表MySQL语句SHOW CREATE DATABASE crashcourse;# 显示创建特定表MySQL语句SHOW CREATE TABLE customers;# 用来显示授予用户的安全权限SHOW GRANTS;# 显示服务器错误或警告信息SHOW ERRORS;SHOW WARNINGS; 检索数据检索单个列12# 从表products中检索一个名为prod_name的列SELECT prod_name FROM products; 检索多个列12#...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/998d504" title="漫画算法"><img class="post-bg" src="https://img.yww52.com/2021/6/2021-6-3top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="漫画算法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/998d504" title="漫画算法">漫画算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-02T16:00:00.000Z" title="发表于 2021-06-03 00:00:00">2021-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="content">如何判断链表有环 给定一个链表，判断链表中是否有环。  循环判断从头节点开始，依次遍历单链表中的每一个节点。没遍历一个新节点，就从头检查新节点之前的所有节点，查看是否相同。若存在相同节点证明链表是有环的。 12345678910111213141516171819public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        int total = 2;        ListNode cur = head.next;        while (cur != null) &#123;            int start = 1;            ListNode node = head;            while (node != cur) &#123;                node = node.next;        ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/b93b977e" title="码出高效Java开发手册"><img class="post-bg" src="https://img.yww52.com/2021/5/2021-5-30top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="码出高效Java开发手册"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/b93b977e" title="码出高效Java开发手册">码出高效Java开发手册</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-05-29T16:00:00.000Z" title="发表于 2021-05-30 00:00:00">2021-05-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/a3d4b987" title="结果类封装"><img class="post-bg" src="https://img.yww52.com/2021/5/2021-5-22top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="结果类封装"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/a3d4b987" title="结果类封装">结果类封装</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-05-21T16:00:00.000Z" title="发表于 2021-05-22 00:00:00">2021-05-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">首先要封装一个响应的枚举，将一些常见的错误写入，一般状态码需要与前端一起制定，以便前端提示错误信息以及发生错误的处理逻辑。 1234567891011121314151617181920212223242526272829303132333435package com.yww.demo.util;/** * 结果状态码枚举 * * @author yww */public enum ResultCode &#123;    /**     * 成功     */    SUCCESS(200, &quot;成功&quot;),    /**     * 服务器错误     */    FAILED(500, &quot;服务器发生错误&quot;);    private Integer status;    private String message;    ResultCode(Integer status, String message) &#123;        this.status = status;        this.message = message;...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/4f2ce235" title="背包专题"><img class="post-bg" src="https://img.yww52.com/2021/4/2021-4-19top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="背包专题"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/4f2ce235" title="背包专题">背包专题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-04-18T16:00:00.000Z" title="发表于 2021-04-19 00:00:00">2021-04-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">01背包 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 v[i]，价值是 w[i]。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。  01背部的特征是每个物品都只有一件，要么选择装进背包要么选择不装进背部。 首先是状态表示，一般都能想到的是二维数组来表示状态dp[i][j]，这个应该表示的是从前i个物品中选取，总体积是j的情况下，总价值最大是多少。 那么可以知道这道题的答案就是dp[N][V]了。 然后是状态转移了。 从题目就可以看出选择的方案，或者说是状态转移的方案。  不选择第i件物品，即可以理解为从第i - 1件物品中选择，不选择第i件物品了，背包容量不变。 dp[i][j] = dp[i - 1][j]  选择第i件物品，即可以理解选择了第i - 1件物品之后，从第i - 1件物品中选择，背包容量变为原容量减去第i件物品的体积，这个方案的前提是当前背包容量大于物品的体积。 dp[i][j] = dp[i - 1][j - v[i]] +...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/3cd0c9b6" title="整合Redis"><img class="post-bg" src="https://img.yww52.com/2021/4/2021-4-2top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="整合Redis"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/3cd0c9b6" title="整合Redis">整合Redis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-04-01T16:00:00.000Z" title="发表于 2021-04-02 00:00:00">2021-04-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">JedisJedis是官网推荐的Java连接工具，类似就是在Java和Redis中增加一层辅助层，辅助你用Java使用Redis。 简单的测试一下使用。 首先创建一个maven项目，导入相关的依赖。 123456&lt;!-- Jedis --&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 连接使用Redis 1234567891011121314package com.yww;import redis.clients.jedis.Jedis;public class config &#123;    public static void main(String[] args) &#123;        // 创建Jedis对象，连接Redis,jedis对象相当于客户端   ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/dd921d98" title="剑指Offer"><img class="post-bg" src="https://img.yww52.com/2021/3/2021-3-19top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指Offer"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/dd921d98" title="剑指Offer">剑指Offer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-03-18T16:00:00.000Z" title="发表于 2021-03-19 00:00:00">2021-03-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">3.数组中重复的数字排序遍历可以直接将数组排序，然后进行循环遍历，就可以找到数组中重复的数字了。 1234567891011class Solution &#123;    public int findRepeatNumber(int[] nums) &#123;        Arrays.sort(nums);        for (int i = 1;i &lt; nums.length; i++) &#123;            if (nums[i] == nums[i - 1]) &#123;                return nums[i];            &#125;        &#125;        return 0;    &#125;&#125; Set去重可以将该数组丢到Set集合里去重，若是添加失败就代表该数字重复，直接返回就好了。 1234567891011class Solution &#123;    public int findRepeatNumber(int[] nums) &#123;       ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/bae4ff13" title="Redis"><img class="post-bg" src="https://img.yww52.com/2021/2/2021-2-15/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/bae4ff13" title="Redis">Redis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-02-14T16:00:00.000Z" title="发表于 2021-02-15 00:00:00">2021-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">什么是NoSQL先来看看百度百科对NoSQL的描述。  NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。  NoSQL维基百科称其为Not Only SQL,在当今的大数据年代，仅仅是关系型数据库已经不能满足当前一些流量较大的Web应用，所以NoSQL就应运而生，就是用来解决数据量较大的问题。 NoSQL可以分成四个大类。  键值存储数据库  列存储数据库  文档型数据库  图形数据库   这里我就用百度百科上的表格，来简单了解一下这四个分类。     分类 Examples举例 典型应用场景 数据模型 优点 缺点     键值存储数据库 Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/b0ab3ebd" title="常用的工具类"><img class="post-bg" src="https://img.yww52.com/2021/2/2021-2-3top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用的工具类"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/b0ab3ebd" title="常用的工具类">常用的工具类</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-02-02T16:00:00.000Z" title="发表于 2021-02-03 00:00:00">2021-02-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">前言 总结记录一下在开发中经常使用到的一些工具类。 MD5加密用户的密码一般都会进行加密后在存储到数据库当中，所以一般用到MD5这种加密算法。 这种加密算法最大的特点就是不可逆，只能加密不能解密。 这是挺简单的一种加密算法了，之后还可以考虑加盐和哈希散列，进行更复杂的加密手段。 123456789101112131415161718192021222324public class Md5Utils &#123;    public static String encrypt(String strSrc) &#123;        try &#123;            char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;,                    &#x27;9&#x27;,...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/c0010af8" title="Shiro"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-25/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shiro"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/c0010af8" title="Shiro">Shiro</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-24T16:00:00.000Z" title="发表于 2021-01-25 00:00:00">2021-01-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">简介网上最流行的两个Java安全框架就是Shiro和spring security。spring security功能更加强大，而Shiro是更加简单。这次就先来学习一下Shiro。首先我们来看看官网上对Shiro的描述。  Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications. Apache Shiro是一个功能强大且易于使用的Java安全框架，用于执行身份验证，授权，加密和会话管理。...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/f1601c3e" title="单例模式"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-23top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/f1601c3e" title="单例模式">单例模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-22T16:00:00.000Z" title="发表于 2021-01-23 00:00:00">2021-01-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Design-pattern/">Design pattern</a></span></div><div class="content">前言单例模式是一个很简单的设计模式，当然这里的简单说的是理解起来很简单，其实单例模式中有很多细节值得我们去深究。 什么是单例模式单例模式顾名思义就是只有一个实例。 每一个单例的类都只会存在一个实例，需要使用到该类时，就需要使用该实例，不得在创建另一个实例对象。 为什么会需要单例模式呢？每次使用类的时候就直接创建对象就好了，何必这么麻烦。 的确在大多数使用类的情况下，单例是没有必要的。但是在某些情况下单例还是很有必要的。 比如需要重复用到的类，就会不断重复创建实例，这个实例完全可以复用，但是还是重新创建了，这样是十分浪费系统资源和性能的。 再比如数据库的连接，如果每次使用都需要连接一次，使用完在断开连接，要是这样的开销完全大于一直连接，那为什么不一直连接直到程序结束呢？ 所以单例模式在一些情况下显得十分必要。 单例模式的实现单例模式实现的方式有很多种，大多都是围绕两个核心的问题来变化的。  何时生成实例，也就是是否是懒加载 是否线程安全  接下来就围绕这两个问题进行探讨。 饿汉式首先是最简单的一种单例模式的实现方法。 123456789public class Singleton...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/ee7e4b9" title="前后端分离demo"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-20top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前后端分离demo"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/ee7e4b9" title="前后端分离demo">前后端分离demo</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-19T16:00:00.000Z" title="发表于 2021-01-20 00:00:00">2021-01-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">开篇当下前后端分离的趋势很明显，的确这也是很有必要的。前后端分离让前端专注于前端，后端专注于后端，而不是哪一方都要学习前后端。学习过JSP的都知道，前后端之前都是套模板，这会让项目很繁琐，而且也提高了项目的耦合性，不利于二次开发，所以现在来通过一个简单的demo来简单的体验一下前后端分离。 涉及技术 Vue  SprtingBoot  Mybatis-plus   准备数据这里的数据我就使用Mybatis-plus官方提供样例的数据了。 1234567891011121314151617181920212223CREATE DATABASE IF NOT EXISTS Company;USE `Company`;DROP TABLE IF EXISTS user;CREATE TABLE user(	id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,	name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,	age INT(11) NULL DEFAULT NULL...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/edea11bc" title="synchronized"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-11/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="synchronized"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/edea11bc" title="synchronized">synchronized</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-10T16:00:00.000Z" title="发表于 2021-01-11 00:00:00">2021-01-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JUC/">JUC</a></span></div><div class="content">应用方式首先要知道synchronized实现同步的基础为Java中每一个对象都可以作为锁，synchronized一般的使用方法有以下三个。  在普通方法上加synchronized，为方法的对象加锁。 在静态方法上加synchronized，为该方法的类模板加锁。 同步方法块，为给定对象加锁。  每一个线程执行到同步块或者是同步方法（对共享内存进行访问的程序片段称为临界区），就会去申请获得锁。当同步的操作执行完或者是抛出异常时就会把该锁给释放掉。 简单应用之前的volatile文章有提过，volatile是不保证原子性的，现在就用synchronized来保证那个例子的原子性。 123456789101112131415161718192021222324252627282930313233343536package com.yw;import java.util.concurrent.CountDownLatch;public class Test&#123;    public static void main(String[] args) throws...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/276e22e" title="2020年度总结"><img class="post-bg" src="https://img.yww52.com/2020/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2020年度总结"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/276e22e" title="2020年度总结">2020年度总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-07T16:00:00.000Z" title="发表于 2021-01-08 00:00:00">2021-01-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/fe4c9cb6" title="volatile"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-8/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="volatile"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/fe4c9cb6" title="volatile">volatile</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-07T16:00:00.000Z" title="发表于 2021-01-08 00:00:00">2021-01-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JUC/">JUC</a></span></div><div class="content">什么是volatilevolatile是Java提供的一个关键字，是一种轻量级的同步方式，也可以理解为轻量级的synchronized。 码出高效Java开发手册中是这样说道。volatile是轻量级的同步方式，这种说法是错误的。它只是轻量级的线程操作可见方式，并非同步方式，如果是多写场景，一定会产生线程安全问题。&lt;/br&gt;这里的错误就不修改了，以便提醒自己。  Java内存结构Java的内存结构其实说的是JVM的运行时数据区。   绿色代表线程私有的内存区域，紫色的代表所有线程共享的内存区域。  Java内存结构在这里就不展开详细说了，这算是JVM的内容了，这里提前主要是提醒一下，不要与下面学习的Java的内存模型混淆，这两个概念说的并不是同一个东西。 JMMJMM，全称为Java Memory...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/195c9969" title="初识JUC编程"><img class="post-bg" src="https://img.yww52.com/2021/1/2021-1-2top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初识JUC编程"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/195c9969" title="初识JUC编程">初识JUC编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-01T16:00:00.000Z" title="发表于 2021-01-02 00:00:00">2021-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JUC/">JUC</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/b020b173" title="CMS垃圾回收器"><img class="post-bg" src="https://img.yww52.com/2020/12/2020-12-13/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMS垃圾回收器"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/b020b173" title="CMS垃圾回收器">CMS垃圾回收器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-12T16:00:00.000Z" title="发表于 2020-12-13 00:00:00">2020-12-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="content">初步了解 CMS GC是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了垃圾收集线程与用户线程同时工作 CMS GC的特点是尽可能减少STW时间，即低延迟，Parallel是吞吐量优先 CMS采用标记-清除算法和Stop The World机制，在空间碎片化严重的时候也会使用一次标记-压缩算法来整理空间  工作流程CMS的工作流程大致分为七个步骤。  初始标记阶段 并发标记阶段 预清理阶段  可被终止的预清理阶段  重新标记阶段  并发清除阶段  并发重置    初始标记阶段这个阶段主要的工作就是标记出GC Roots能直接关联的对象，这里可分为两部分。  标记老年代所有的GC Roots对象 标记年轻代中活着的对象引用到老年代的对象  这个阶段因为涉及到了GC...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/32849422" title="腾讯精选练习50题"><img class="post-bg" src="https://img.yww52.com/2020/12/2020-12-12top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="腾讯精选练习50题"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/32849422" title="腾讯精选练习50题">腾讯精选练习50题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-11T16:00:00.000Z" title="发表于 2020-12-12 00:00:00">2020-12-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">7.整数反转利用long来进行中转。 12345678910class Solution &#123;    public int reverse(int x) &#123;        long res = 0;        while (x != 0) &#123;            res = res * 10 + x % 10;            x = x/10;        &#125;        return (int)res == res?(int)res : 0;    &#125;&#125; 9. 回文数解法一回文数，其实跟回文字符串差不多，只是处理不同而已，我这里就直接将数字转换成了字符串然后对比。 123456789101112class Solution &#123;    public boolean isPalindrome(int x) &#123;        if(x &lt; 0) return false;        if (x &lt; 10) return true;        String str =...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/202acec1" title="GC垃圾回收机制"><img class="post-bg" src="https://img.yww52.com/2020/12/2020-12-7/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GC垃圾回收机制"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/202acec1" title="GC垃圾回收机制">GC垃圾回收机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-06T16:00:00.000Z" title="发表于 2020-12-07 00:00:00">2020-12-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/c1baee3f" title="初识JVM"><img class="post-bg" src="https://img.yww52.com/2020/12/2020-12-4/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初识JVM"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/c1baee3f" title="初识JVM">初识JVM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-03T16:00:00.000Z" title="发表于 2020-12-04 00:00:00">2020-12-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="content">什么是JVM认识JVM之前就先了解下面三个相近的概念。  JDK英文名称为Java Development Kit。Java开发工具包，开发Java程序经常会使用它。  JRE 英文名称为Java Runtime Environment。Java运行环境，主要包括JVM和一些类库，保证Java程序运行的最小环境。  JVM 英文名称为Java Virtual...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/f2e39350" title="SpringBoot整合Druid"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-25top_img2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot整合Druid"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/f2e39350" title="SpringBoot整合Druid">SpringBoot整合Druid</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-24T16:00:00.000Z" title="发表于 2020-11-25 00:00:00">2020-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">简介Druid是的一个阿里巴巴的开源项目，它是一个数据库连接池的实现。Druid能够提供强大的监控和扩展功能。这次就用SpringBoot来整合Druid。 依赖12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt;    	&lt;!--WEB的场景启动器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    	&lt;!--Mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;           ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/a8057909" title="SpringBoot使用JDBC"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-25top_img1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot使用JDBC"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/a8057909" title="SpringBoot使用JDBC">SpringBoot使用JDBC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-24T16:00:00.000Z" title="发表于 2020-11-25 00:00:00">2020-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">简介在SpringBoot中简单的使用JDBC,用jdbcTemplate简单的操作数据的增删改查，大型一点的项目建议使用Mybatis。 依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt;        &lt;!--JDBC的场景启动器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;    	&lt;!--WEB的场景启动器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/e67586ad" title="SpringBoot使用Mybatis"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-25top_img3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot使用Mybatis"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/e67586ad" title="SpringBoot使用Mybatis">SpringBoot使用Mybatis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-24T16:00:00.000Z" title="发表于 2020-11-25 00:00:00">2020-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">简介Mybatis是现在十分流行的数据持久化框架，这次就来用SpringBoot来整合使用Mybatis。 依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;dependencies&gt;&lt;!-- Mybatis场景启动器 --&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;2.1.1&lt;/version&gt;      &lt;/dependency&gt;&lt;!-- web场景启动器 --&gt;     ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/3d614825" title="HashMap"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-20/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/3d614825" title="HashMap">HashMap</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-19T16:00:00.000Z" title="发表于 2020-11-20 00:00:00">2020-11-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">简介HashMap是Map经常使用的一个实现类,也是我们经常用到的一个集合，所以很有必要去了解一下。JDK8相对JDK7优化了不少，结构也改变了，所以这里就分开来学习了。 因为我英语不是特别好，所以有些源码的文档注释是机翻的，所以有些文档注释读起来怪怪的，只能理解一下大概意思。  JDK7参数和变量1234567891011121314/** * 默认的初始容量，必须是2的幂，默认16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 这是HashMap的最大容量，值为1&lt;&lt;30。要是传入更高的值，就会使用这个最大容量 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * HashMap默认的负载因子 */static final float DEFAULT_LOAD_FACTOR =...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/7b216a3b" title="树"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-23top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7b216a3b" title="树">树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-17T16:00:00.000Z" title="发表于 2020-11-18 00:00:00">2020-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">94. 二叉树的中序遍历递归1234567891011121314class Solution &#123;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        if (root == null) return res;        fnc(root);        return res;    &#125;    public void fnc(TreeNode node) &#123;        if (node == null) return;        fnc(node.left);        res.add(node.val);        fnc(node.right);   ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/fd1960c6" title="Mybatis-plus"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-14/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis-plus"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/fd1960c6" title="Mybatis-plus">Mybatis-plus</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-13T16:00:00.000Z" title="发表于 2020-11-14 00:00:00">2020-11-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">简介MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。  官网地址  快速开始参照官网快速开始的样例，官网用的是h2数据库，我这里用的是Mysql。   创建数据库schema，并执行以下脚本。 12345678910111213141516171819DROP TABLE IF EXISTS user;CREATE TABLE user(	id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,	name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,	age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,	email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,	PRIMARY KEY (id));DELETE FROM user;INSERT INTO user...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/53d0684b" title="Linux"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-11/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/53d0684b" title="Linux">Linux</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-10T16:00:00.000Z" title="发表于 2020-11-11 00:00:00">2020-11-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">虚拟机网络    连接方式 连接的网卡 能否连接局域网 能否连接公网     桥接 VMnet0(本地真实网卡) 可以 可以   NAT VMnet8 不可以 可以   仅主机 VMnet1 不可以 不可以      桥接连接的网卡是随机连接的，要是连接到了没网络的网卡还需要自己设置。 桥接模式下虚拟机相当一台独立的计算机，拥有一个独立的IP地址，与本机在一个局域网内。 NAT模式可以帮助虚拟机通过本机所在的网络来访问公网。 仅主机模式会建立一个全封闭的虚拟网络，只有主机能访问  目录结构 常用命令目录命令ls12345678# 查看文件夹的信息	ls # 查看详细信息	ls -l# 查看隐藏目录	ls -a # 显示文件大小	ls -lh cd12345678# 进入目录	cd [路径]# 进入家目录	cd ~# 进入上一次所在的目录	cd -# 进入上一级目录	cd .. mkdir和rmdir12345678# 创建目录	mkdir [目录名]# 删除目录，只能删除空目录	rmdir [目录名]# 递归建立目录	mkdir -p [目录路径]#...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/683134ab" title="记一次容器编排"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-10top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次容器编排"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/683134ab" title="记一次容器编排">记一次容器编排</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-09T16:00:00.000Z" title="发表于 2020-11-10 00:00:00">2020-11-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></span></div><div class="content">前言老师丢了一个spring写的项目给我们部署到服务器上。这次来记录一下部署的过程。 分析项目这是一个spring的项目，没用到springboot，只能用tomcat部署了。因为还用到了MySQL连接，所以还需要一个MySQL的容器。知道了需要的容器那就开始行动了。 构建好大概框架 创建一个项目的文件夹 12mkdir mathcd math  创建一个放Tomcat配置的文件夹 1mkdir webapp  创建一个放MySQL配置的文件夹 1mkdir database  创建一个docker-compose.yml的配置文件 1touch...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/35ca0e58" title="Swagger3"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-3top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Swagger3"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/35ca0e58" title="Swagger3">Swagger3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-02T16:00:00.000Z" title="发表于 2020-11-03 00:00:00">2020-11-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/API%E6%96%87%E6%A1%A3/">API文档</a></span></div><div class="content">前言学完之前的swagger2之后,发现还有一个新的版本，swagger3，用起来更加的简单，而且是官方的starter。 使用 首先导入依赖 12345&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;  创建swagger配置类。 1234567package com.yww.config;import org.springframework.context.annotation.Configuration;@Configurationpublic class swaggerConfig...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/c24675b4" title="MySQL"><img class="post-bg" src="https://img.yww52.com/2020/11/2020-11-1top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/c24675b4" title="MySQL">MySQL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-31T16:00:00.000Z" title="发表于 2020-11-01 00:00:00">2020-11-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">基本概念连接数据库12345-- username 则为自己的用户名，一般为root，password为密码	mysql -u[username] -p[password]	mysql -u[username] -p-- 断开连接，即退出数据库操作页面	exit MySQL的关键字是不区分大小写的，这里我全部用大写来记录。  DDL数据定义语言数据库操作创建数据库12CREATE DATABASE [数据库名];CREATE DATABASE IF NOT EXISTS [数据库名]; 删除数据库12DROP DATABASE [数据库名];DROP DATABASE IF EXISTS [数据库名]; 查看数据库1234-- 查看所有的数据库	SHOW DATABASES;-- 查看创建库使用的语句	SHOW CREATE DATABASES [库名]; 切换数据库123-- 切换到指定的数据库	USE [数据库名];-- ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/f5f9fa9b" title="Docker"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-27/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/f5f9fa9b" title="Docker">Docker</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-26T16:00:00.000Z" title="发表于 2020-10-27 00:00:00">2020-10-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></span></div><div class="content">官网https://www.docker.com/ Docker的安装去到官方文档https://docs.docker.com/get-docker/，选择对应的操作系统安装就可以了。 我的环境是CentOS 7.8 123456789101112131415161718# 下载需要的安装包	yum install -y yum-utils# 更新yum软件包的索引	yum makecache fast# 安装docker	yum install docker-ce docker-ce-cli containerd.io# 启动docker	systemctl start docker# 建立docker组	sudo groupadd docker# 将当前用户加入docker组	sudo usermod -aG docker $USER# 查看版本	docker version# 查看docker的信息	docker info# 查看帮助命令	docker...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/bf71eba1" title="swagger"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-26/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="swagger"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/bf71eba1" title="swagger">swagger</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-25T16:00:00.000Z" title="发表于 2020-10-26 00:00:00">2020-10-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/API%E6%96%87%E6%A1%A3/">API文档</a></span></div><div class="content">简单的集成swagger 为你的项目导入两个依赖 123456789&lt;dependency&gt;      &lt;groupId&gt;io.springfox&lt;/groupId&gt;      &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;      &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;io.springfox&lt;/groupId&gt;      &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&lt;/dependency&gt;  创建一个配置类 123456789package com.yww.config;import org.springframework.context.annotation.Configuration;import...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/79666db" title="数据结构"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-23top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/79666db" title="数据结构">数据结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-22T16:00:00.000Z" title="发表于 2020-10-23 00:00:00">2020-10-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/bc6b6e0d" title="YAML基本语法"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-20top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YAML基本语法"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/bc6b6e0d" title="YAML基本语法">YAML基本语法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-19T16:00:00.000Z" title="发表于 2020-10-20 00:00:00">2020-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">基本语法1Key: value 注意冒号后面的空格是一定要有的，YAML语法对空格是十分敏感的，而且是用空格来控制层级关系，就比如下面这个例子。 123server: port: 8081 path:  这就表示server这个配置有两个子配置，这两个子配置是port和path，它们都在同一个层级，主要是看首字母的列数，子配置的首字母列数是不能在父配置的左边的比如下面的这个列子就是错误。 12 server:port: 8081 YAML对大小写敏感，所以不要弄错大小写。  值 值为数字，字符串或者是布尔类型 1Key: value 字符串默认是不用加引号的，也可以加上，单引号包括是换转义特殊字符的，而双引号不会，就比如经常写的\n换行等字符。  对象和Map 123User: Name: student ID: 02 1User: &#123;Name: student,ID: 02&#125;  数组 1234User: - user01 - user02 - user03 1User: [user01,user02,user03]   </div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/6f2612a2" title="SpringBoot"><img class="post-bg" src="https://img.yww52.com/2020/10/2020-10-15top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/6f2612a2" title="SpringBoot">SpringBoot</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-14T16:00:00.000Z" title="发表于 2020-10-15 00:00:00">2020-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="content">SpringBootSpringBoot是一个全新开源的轻量级框架。它基于Spring4.0设计，进一步简化了Spring的配置，更加简单的完成整个搭建和开发。 微服务架构https://martinfowler.com/articles/microservices.html 第一个SpringBoot程序可以去官网去创建一个springboot的项目（用idea自带创建也是通过官网创建的），配置什么的自己选择，注意要添加一个Spring Web的依赖，不然不能用作Web开发，然后GENERATE下载项目到本地，用idea导入项目就可以了。 在项目自带的Application类的同级目录下（一定要同级目录，不然SpringBoot无法扫描到你写的类）创建包和类，现创建一个Hello的类。 123456789@Controller@ResponseBody//将返回的数据写给浏览器，对象就会返回JSON数据//这两个由@RestController替换，因为这两个注解已经被RestController注解包括了。public class Hello &#123;   ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/16bca3f0" title="第十一届蓝桥杯第二次模拟赛">第十一届蓝桥杯第二次模拟赛</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-14T16:00:00.000Z" title="发表于 2020-10-15 00:00:00">2020-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/7a197da5" title="SpringMVC执行原理"><img class="post-bg" src="https://img.yww52.com/2020/9/2020-9-22/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC执行原理"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7a197da5" title="SpringMVC执行原理">SpringMVC执行原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-09-21T16:00:00.000Z" title="发表于 2020-09-22 00:00:00">2020-09-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/dcaabd92" title="IntelliJ IDEA的优化配置"><img class="post-bg" src="https://img.yww52.com/2020/7/2020-7-11/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IntelliJ IDEA的优化配置"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/dcaabd92" title="IntelliJ IDEA的优化配置">IntelliJ IDEA的优化配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-07-10T16:00:00.000Z" title="发表于 2020-07-11 00:00:00">2020-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">前言闲着没事升级了一下我的idea，现在版本为2020.1.3，顺便记录一下idea的配置与优化，方便以后再改。 主题方面一个好的主题会让你喜欢上idea，所以可以去换一个喜欢的主题，体验超好。网上有很多去下载就好了，我就不放地址了。点击下载一般都会下一个jar包，随便找个地方放就好。 然后在idea里的File -&gt; Manage IDE settings -&gt; import settings,把jar包导进去重启就好了。 设置优化 idea主色配置File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; Appearance  这个看个人喜欢了，我用多了还是深色的好。   自动导包 File -&gt; Settings -&gt; Editor -&gt; General -&gt; Auto Import   这个就不用多说了吧，自动导包还是很方便的。   字体缩放File -&gt; Settings -&gt; Editor -&gt;...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/ae0f95e0" title="SpringMVC"><img class="post-bg" src="https://img.yww52.com/2020/7/2020-7-7/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/ae0f95e0" title="SpringMVC">SpringMVC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-07-06T16:00:00.000Z" title="发表于 2020-07-07 00:00:00">2020-07-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">什么是SpringMVCSpring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一部分，它和Struts2一样都属于表现层的框架。  MVC可参考之前的文章    mvc架构  第一个SpringMVC程序 新建一个maven项目，取个名字一路next即可。  添加web的支持  在pom.xml导入依赖 12345678&lt;dependencies&gt;       &lt;!--spring-webmvc--&gt;       &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;      ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/4a19524b" title="Ngrok内网穿透"><img class="post-bg" src="https://img.yww52.com/2020/7/2020-7-3/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ngrok内网穿透"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/4a19524b" title="Ngrok内网穿透">Ngrok内网穿透</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-07-02T16:00:00.000Z" title="发表于 2020-07-03 00:00:00">2020-07-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">什么是Ngrokngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 有什么用内网穿透意思是能让外网访问到你本地，就比如你在本地运行tomacat等，外网是无法访问到你本地的项目的，当然你部署到服务器上就可以，这篇文章只是为了简化你的操作，而且你应该不会什么测试都部署到服务器，所以就能使用ngrok实现内网穿透。 注册先去官网注册一个用户，然后登陆。国内Ngrok的地址：https://www.ngrok.cc/ 购买隧道 这个是免费的，当然你想体验更流畅那就付费呗。  使用  把你的隧道ID输入就好了 然后你就能用赠送的域名访问到你的内网了。  后话这只是个简单的穿透，不过也挺有用的，能让外网访问到你的本地项目，在一些时候能很方便。你不想用他的域名，应该是可以解析的，解析成你的就好。 </div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/92933cdb" title="AOP"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-30/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AOP"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/92933cdb" title="AOP">AOP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-29T16:00:00.000Z" title="发表于 2020-06-30 00:00:00">2020-06-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">什么是AOPSpring 是一个轻量级的IOC和AOP的框架，spring的两大核心就是IOC和AOP，IOC我之前写有，那什么是AOP呢？首先先看一下百度的定义。  在软件业，AOP为Aspect Oriented...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/7b510e10" title="代理模式"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-28top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理模式"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7b510e10" title="代理模式">代理模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-27T16:00:00.000Z" title="发表于 2020-06-28 00:00:00">2020-06-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Design-pattern/">Design pattern</a></span></div><div class="content">什么是代理模式代理模式顾名思义就是为一个对象提供一个代理，并让其他对象通过代理对象来控制这个对象。代理模式又分为两种，一种叫静态代理，一种叫动态代理。 静态代理角色分析 Isubject抽象角色，一般使用接口和抽象类，不过抽象类不怎么好用，大多都是接口。 RealSubject真实角色，被代理的角色。 Proxy代理角色，代理真实角色  代码实现1光用文字描述，会觉得十分的绕，还是用代码来讲解一下吧。首先先模拟一下环境，比如买火车票这件事情。卖火车票这件事情就是一个抽象角色，我们为它创建一个接口。 123public interface buyTickets &#123;    void buytickets();&#125; 有买票的人也就会有卖的人，这里是卖票的设为火车站。这样的话火车站就是一个真实角色，为它创建一个类。 12345public class Station implements buyTickets &#123;    public void buytickets() &#123;       ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/419e09e5" title="环境搭建手册"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-27top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="环境搭建手册"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/419e09e5" title="环境搭建手册">环境搭建手册</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-26T16:00:00.000Z" title="发表于 2020-06-27 00:00:00">2020-06-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">前言为了以后更好的做个cv工程师，所以现在总结一下配置。 我的环境 IntelliJ IDEA 2020.2.2 Mysql  8.0.18 Tomcat  9.03.5 maven  3.6.1 jdk  1.8  Servlet更新web.xml123456&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;        ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/7f09f5da" title="Spring5"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-26top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring5"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7f09f5da" title="Spring5">Spring5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-25T16:00:00.000Z" title="发表于 2020-06-26 00:00:00">2020-06-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">简介​            Spring是Java EE编程领域的一个轻量级开源框架，该框架由一个叫Rod Johnson的程序员在 2002 年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架 。Spring是一个开源容器框架，它集成各类型的工具，通过核心的Bean factory实现了底层的类的实例化和生命周期的管理。在整个框架中，各类型的功能被抽象成一个个的 Bean，这样就可以实现各种功能的管理，包括动态加载和切面编程。  Spring 就是一个轻量级的控制反转IOC和面向切面AOP的框架。  参考网站：  官网 官方下载地址 GitHub地址  第一个Spring程序 创建一个maven项目  在pom.xml里导入依赖 1234567&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;           ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/183e2cbd" title="IOC"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-23top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IOC"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/183e2cbd" title="IOC">IOC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-22T16:00:00.000Z" title="发表于 2020-06-23 00:00:00">2020-06-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">前言今天看了Iteye的开涛对IOC的理解，原文地址，对IOC的有了一些理解，所以来记录一下。 什么是IOCIOC全称为Inversion of...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/85d837e1" title="Javase"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-18top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Javase"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/85d837e1" title="Javase">Javase</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-17T16:00:00.000Z" title="发表于 2020-06-18 00:00:00">2020-06-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">前言以前都是记笔记，每篇文章都很短而且很乱，现在学完很久了，有些东西都快忘了，最近又刚刚整完主题，所以索性就整理一下前面的文章，顺便整合起来复习一下。 这是我学习JavaSE的时候记的笔记，文章较长，建议目录直接跳转  什么是JavaSE复习前先来看看什么是JavaSE，来看看百度百科是怎么描述的。（大概了解一下就好了）  Java SE（Java Standard Edition，Java 标准版）是Java技术的核心和基础，是Java ME和Java EE编程的基础 [1] 。Java SE是由Sun...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/70b61401" title="博客主题更换">博客主题更换</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-16T16:00:00.000Z" title="发表于 2020-06-17 00:00:00">2020-06-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">前言​        前几天，在b站逛逛，突然看到一个花里胡哨的主题—-Butterfly，的确还挺好看的，至少比next的好看（个人意见），所以便决定换掉我的next主题。 Butterfly​        就因为换个主题，我玩了一天的yml，这些前端的东西，对于我只学了一点点的人来说确看的云里雾里，不过Butterfly作者也很照顾我们这些不懂的人，主题配置文档写的清清楚楚，很多功能就是改个值就能启动，也很方便。（好了吹到这里） 关于魔改​        我是菜鸟，玩了两天还是没玩出来，结果还是是照抄小康大佬和 XueXi大佬的（感谢大佬的教程），虽然花里胡哨，但是好看就完事了。 指路 Butterfly主题 小康 XueXi Lete  </div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/da3e1361" title="Mybatis"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-8/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/da3e1361" title="Mybatis">Mybatis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-07T16:00:00.000Z" title="发表于 2020-06-08 00:00:00">2020-06-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/SSM/">SSM</a></span></div><div class="content">Mybatis简介​        MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。可以参考官网学习Mybatis Mybatis简单使用 创建maven项目，与之前的第一个servlet程序的流程一样  配置环境，在父项目的pom.xml导入依赖,pom.xml如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt;&lt;project...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/78b18e67" title="JSP"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-6/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JSP"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/78b18e67" title="JSP">JSP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-05T16:00:00.000Z" title="发表于 2020-06-06 00:00:00">2020-06-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/javaweb/">javaweb</a></span></div><div class="content">前言​        JSP是一门比较老的技术了，在这个前后端分离大火的时代，JSP基本已经被淘汰了，但是JSP还是有学习的必要的，学习了JSP有助于了解JavaWeb，能更好的理解后面所学的框架。 什么是JSP​        JSP全称为JavaServer Pages,Java服务端页面，是一种动态网页技术，用于实现动态web。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML,XML或其他格式文档的web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。 JSP原理JSP是怎么实现动态web​       ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/26bc41e8" title="第一个Servlet程序"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-5/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一个Servlet程序"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/26bc41e8" title="第一个Servlet程序">第一个Servlet程序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-04T16:00:00.000Z" title="发表于 2020-06-05 00:00:00">2020-06-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/javaweb/">javaweb</a></span></div><div class="content"> 创建一个Maven项目，不用选择模板先   导入依赖  1234567891011121314151617&lt;!--在pom.xml的project标签里导入依赖--&gt;&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;4.0.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;           ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/afc5caff" title="简单的Web基础"><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-4/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单的Web基础"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/afc5caff" title="简单的Web基础">简单的Web基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-03T16:00:00.000Z" title="发表于 2020-06-04 00:00:00">2020-06-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/javaweb/">javaweb</a></span></div><div class="content">web应用web应用程序是一个可以提供浏览器访问的程序，一个web服务器应该是由多部份组成的，前端页面，webService功能，和Java程序，等等 静态web​        静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html （ htm ）文件，这种网站每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件  动态web​        动态web有点类似静态web，但不是那种有图片动，轮播图的那些伪动态，它的资源数据不是一成不变的，就比如是淘宝，不同的人会有不同的推荐​         web服务器​        web服务器用来处理用户的请求，然后返回响应。有LLS,Tomcat服务器，我们主要学的就是Tomcat服务器。现在来了解一下Tomcat服务器。 Tomcat​            Tomcat是Apache 软件基金会（Apache...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/4447e73e" title="关于equels与=="><img class="post-bg" src="https://img.yww52.com/2020/6/2020-6-1top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于equels与=="></a></div><div class="recent-post-info"><a class="article-title" href="/posts/4447e73e" title="关于equels与==">关于equels与==</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-06-01T06:39:11.000Z" title="发表于 2020-06-01 14:39:11">2020-06-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">前言​        在初学Java的时候，equels与==总是会感觉很混乱，这次特意来总结一下。首先来大致了解一下这两个的意思。  ==作用是来判断两个对象是不是同一个对象，因为Java只有值传递，所以对于==来说不管是基本的数据类型还是引用的数据类型，其本质比较的都是值，只是引用的数据类型变量的值是对象的地址。所以就会容易搞混  equals方法也是比较两个对象是否相等。equals方法是Object类中的方法。 1234//这是Object类中的equals方法public boolean equals(Object obj)&#123;    return(this == obj);&#125;   在基本数据类型中的比较​    基本数据类型不能算做为对象，所以并没有继承有equals的方法，所以只有==的比较 1234	 int num1 = 15;     int num2 = 15;    System.out.println(num1==num2);// 运行结果为true，==判断值是否相等 在引用数据类型中的比较String类型中的比较​   ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/6fc8eab5" title="Markdown"><img class="post-bg" src="https://img.yww52.com/2020/5/2020-5-15top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/6fc8eab5" title="Markdown">Markdown</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-05-14T16:00:00.000Z" title="发表于 2020-05-15 00:00:00">2020-05-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">标题 使用=和-来标记一级和二级标题 1234一级标题=============二级标题-----------------  使用#来标记标题 1234567# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题// 推荐这种写法   字体   1234567*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___//效果图如下  斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本  特定格式 分割线 123456**** * ******- - -----------//  这些方式都可以代表分隔线，符号只要大于三个，有无空格都可以，效果就像下方这条线     删除线 1~~删除线~~  删除线   下划线 1下划线就用&lt;u&gt;标签  脚注 12//[^脚注]  //[^脚注]:脚注的内容    列表 有序列表 12345678910* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项-...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/dc9cb9f1" title="Matlab">Matlab</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-12-08T16:00:00.000Z" title="发表于 2019-12-09 00:00:00">2019-12-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">基本操作123456%	定义变量		syms a%	清屏	clc%	清空所有	clear 矩阵的操作123456789101112%	定义矩阵,空格或逗号分隔一行里的元素，分号是分行	a = [ ; ; ]%	定义元素全为1的矩阵	A1 = ones(2,4)%	定义元素全为0的矩阵	A2 = zeros(3,3)%	定义单位矩阵	A3 = eye(4)	%	定义随机数的矩阵	A4 = rand(2,3)%	定义魔方矩阵，每行每列没对角线的和相等	A5 = magic(3) 123456789101112%	求A行列式的值	det(A)%	求A矩阵的秩(r(A))	rank(A)%	求A矩阵的迹(tr(A))	trace(A)%	求A行列式的逆矩阵	inv(A)%	求A的特征值与特征向量	eig(A)%	化简矩阵A	rref(A) 克莱姆法则求解1234567% 克莱姆法则求解非齐次线性方程组的解% 判断行列式是否为0，不为0即有唯一解	D = det(A)%然后用结果那一列换到行列式里，得D1,D2等	x1 = D1/D 	x2 = D2/D ....%...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/423abe9e" title="git常用命令"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-28/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git常用命令"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/423abe9e" title="git常用命令">git常用命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-27T16:00:00.000Z" title="发表于 2019-11-28 00:00:00">2019-11-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">本地库操作git的签名123456789#用户名和邮件地址又称签名#系统用户级别的签名设置（这个是一定要设置的）	git config --global user.name name	git config --global user.email email#仓库级别的签名设置	git config user.name name 	git config user.email email#这两个签名就是范围不同，一个是全局的一个是部分的，当两个签名都存在时，就会使用仓库级别的签名#注意的是，用户名不能是中文的 git的添加和删除123456#将操作提交的暂存区	git add file#将所有操作都提交到暂存区	git add .#将操作从暂存区删除掉	git rm --cached file git提交123456#将暂存区中没提交的操作提交到本地版本库	git commit file#因为git每次提交都需要写日志来清楚知道修改了什么，所以可以这么写	git commit -m&quot;message&quot;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/54d98528" title="如何给你的U盘或移动硬盘自定义图标">如何给你的U盘或移动硬盘自定义图标</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-27T10:21:00.000Z" title="发表于 2019-11-27 18:21:00">2019-11-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%A0%E7%B1%BB%E5%8F%AF%E5%88%86/">无类可分</a></span></div><div class="content">操作步骤首先，选好自己想要自定义的图片，将该图片转为32*32的ico文件。关于怎么转换，直接上网搜就好了。 然后新建一个 autorun.inf 文件，并编辑里面的内容为如下 12[autorun]icon=icon.ico emm,那个icon.ico就是你那个图片转化之后的ico文件，名字是可以修改的，只要autorun.inf的文件内容里也跟着修改就行了，然后将ico的图片和那个 autorun.inf文件放在移动硬或U盘的根目录下面就完工了。如果你是U盘，就拔掉在插入，如果是移动硬盘可能就要重启了。 关于可能出现的问题当你新建好 autorn.inf这个文件后，将它移入U盘，或者直接在U盘下新建 autorn.inf这个文件，可能系统会提示你没有权限执行。这个问题也卡了我好久，对于这个问题你就要赋予U盘所有的权限，即你的用户需要是管理员权限，当你弄好权限后就可以将 autorn.inf这个文件放进U盘了。 不过可能系统还会告诉你你没有权限执行，这里我也是查了好久，最后我查了一下...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/a8fe19e2" title="HCS"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-25top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HCS"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/a8fe19e2" title="HCS">HCS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-24T16:00:00.000Z" title="发表于 2019-11-25 00:00:00">2019-11-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">HTML Hyper Text Markup Language         超文本标记语言由标签构成的语言，标记语言不是编程语言   HTML文档后缀名为html或htm  标签可分为围堵标签和自闭和标签。围堵标签就是有开始标签和结束标签，比如&lt;html&gt;&lt;/html&gt;。自闭和标签就是开始标签和结束标签是在一起的，比如 &lt;br/&gt;  标签可以嵌套  在开始标签中可以定义属性。属性是由键值对构成的，值需要用引号引出，单引号或双引号都可以  标签不区分大小写 12345678&lt;html&gt;    &lt;head&gt;        &lt;title&gt; title &lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;font color=&quot;red&quot;&gt;Hello world&lt;/font&gt;    &lt;/body&gt;&lt;/html&gt;    标签文件标签 html : ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/7af799fd" title="反射"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-13top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="反射"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/7af799fd" title="反射">反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-13T05:24:44.000Z" title="发表于 2019-11-13 13:24:44">2019-11-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">反射 反射指的是可以在运行时加载，使用编译期间完全未知的类  程序在运行中。可以动态加载一个只有名称的类。对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性  一个类只有一个Class对象，在加载一次出来的Class对象也是之前的那一个  加载完类之后，在堆内存里就会产生一个Class对象，类的整个结构信息会放到对应的Class对象中   获取Class对象的三种方式：  1234567891011121314151617181920212223public class ReflectionTest &#123;    public static void main(String[] args)  &#123;//      1.用Class.forName()获取Class对象，推荐使用这个        try &#123;            Class clazz1 = Class.forName(&quot;gui.beantest&quot;);//Class.forName(包名+类名)         ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/a70f4376" title="注解"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-12top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="注解"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/a70f4376" title="注解">注解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-12T10:12:00.000Z" title="发表于 2019-11-12 18:12:00">2019-11-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">作用 可以对程序作出解释，但又不是程序的部分，这一点跟注释差不多 可以被程序读取，注解信息处理流程是注解和注释的区别  一些常见的注解 @Override定义在java.lang.Override里，该注解只修饰方法，表示这个方法是重写了超类的方法 @Deprecated定义在java.lang.Deprecated里，可修饰方法，属性，类，表示不建议使用这个元素，使用时会出现划线 @SuppressWarnings()定义在java.lang.SuppressWarnings里，用来抑制编译时的警告信息，不过要往里加一个参数才能使用，比如”all”等  自定义的注解 元注解是为注解做的注解，如@Target,@Retention,@Documented,@Inherited，位于java,lang,annotation  @Target，用于描述注解的使用范围  1@Target(value =...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/8fe47ff4" title="JDBC"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-06top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDBC"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/8fe47ff4" title="JDBC">JDBC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-06T14:01:10.000Z" title="发表于 2019-11-06 22:01:10">2019-11-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">MySQL的安装   去Mysql官网下载即可 数据库管理工具   因为MySQL命令行操作在用起来十分繁琐，所以需要选择一个数据库的管理工具，方便使用MySQL，推荐使用  navicat 装载驱动 为什么要装驱动         在编程中连接数据库时，必须先装载特定厂商的数据库驱动程序，不同的数据库有不同的装载方法。驱动就是各个数据库厂商实现的Sun公司提出的jdbc接口。即对connection等接口的实现类的jar文件。  下载驱动 首先要先去官网下载好对应版本的jar包，我的就是mysql-connector-java-8.0.18，版本要对应，不知道版本的可以使用命令行进去MySQL然后输入命令\s来查看版本   连接数据库 旧版本的连接(8.0版本之前)       12345//装载MySQL驱动    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//连接MySQL数据库    connection con =            ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/posts/2f57a694" title="正则表达式"><img class="post-bg" src="https://img.yww52.com/2019/11/2019-11-03top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正则表达式"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/2f57a694" title="正则表达式">正则表达式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-11-03T08:19:00.000Z" title="发表于 2019-11-03 16:19:00">2019-11-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="content">简介 正则表达式时一种强大而灵活的文本处理工具，用于文本的复杂处理  正则表达式就是描述了一个规则，通过这个规则可以匹配一类字符串   语法 普通字符字母，数字，汉字，下划线以及没有特殊定义的标点符号都是普通字符。表达式中的普通字符在匹配一个字符串时，匹配与之相同的一个字符  简单的转义字符 1234567\n		代表换行符\t		代表制表符\\		代表\本身还有一些特殊的字符表达  标准字符集合 12345678\d		任意一个数字\w	  	任意一个字母，数字或下划线\s		包括空格，制表符，换行符等空白字符的其中任意一个.		小数点可以匹配任意一个字符(除了换行符)  				注意大小写，若是大写则代表相反的意思，比如 \D 表示除了数字之外的字符  自定义字符集合  方括号的匹配方式，能够匹配方括号中任意一个字符，比如 123[123]		匹配1，2，3字符[2-8]		匹配2~8的数字[ ^123...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/posts/92a59ea9" title="static与final"><img class="post-bg" src="https://img.yww52.com/2019/10/2019-10-31top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="static与final"></a></div><div class="recent-post-info"><a class="article-title" href="/posts/92a59ea9" title="static与final">static与final</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-10-31T11:25:01.000Z" title="发表于 2019-10-31 19:25:01">2019-10-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">static static修饰的变量为类的变量，属于类，即所有的该类的实例化对象共同使用该static变量  static方法中不能访问非static成员  这个很容易理解，每个类都只有一份static的资源，还没类还没实例化就有了该static方法，但没有实例化的成员即非静态成员，所以静态方法是不能访问非static成员的   static的变量和方法或者块都是属于类的，普通变量和方法是属于对象的。   final 用final修饰类，表明中这个类是不能不继承的，类中的变量可以是非final的变量，但所有的方法都会被隐式地指定为final方法 使用final修饰方法原因有两个。一，把方法锁定，防止任何继承类重写该方法。二，提高效率。在早期的Java实现版本会将final方法转为内嵌调用，但如果方法过于庞大，可能看不到内嵌的优化效果，新的Java版本已经   不需要final方法来优化  final不能修饰构造方法  final修饰变量，即表示该变量被定义为一个常量，该常量被初始化赋值之后就不能修改  </div></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yww</div><div class="author-info-description">debug myself</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/91f4854c" title="Java图片处理"><img src="https://img.yww52.com/2023/4/2023-4-18top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java图片处理"/></a><div class="content"><a class="title" href="/posts/91f4854c" title="Java图片处理">Java图片处理</a><time datetime="2023-04-17T16:00:00.000Z" title="发表于 2023-04-18 00:00:00">2023-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/58d09dd7" title="开发环境配置"><img src="https://img.yww52.com/2023/4/2023-4-11top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/posts/58d09dd7" title="开发环境配置">开发环境配置</a><time datetime="2023-04-10T16:00:00.000Z" title="发表于 2023-04-11 00:00:00">2023-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4e5ad84e" title="MybatisPlus常用方法"><img src="https://img.yww52.com/2023/2/2023-2-2top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisPlus常用方法"/></a><div class="content"><a class="title" href="/posts/4e5ad84e" title="MybatisPlus常用方法">MybatisPlus常用方法</a><time datetime="2023-02-01T16:00:00.000Z" title="发表于 2023-02-02 00:00:00">2023-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/622a5765" title="2022年度总结"><img src="https://img.yww52.com/2023/1/2023-1-1/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022年度总结"/></a><div class="content"><a class="title" href="/posts/622a5765" title="2022年度总结">2022年度总结</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e31003e0" title="SpringBoot部署启动"><img src="https://img.yww52.com/2022/09/2022-9-28top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot部署启动"/></a><div class="content"><a class="title" href="/posts/e31003e0" title="SpringBoot部署启动">SpringBoot部署启动</a><time datetime="2022-09-27T16:00:00.000Z" title="发表于 2022-09-28 00:00:00">2022-09-28</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Design-pattern/"><span class="card-category-list-name">Design pattern</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">20</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/JUC/"><span class="card-category-list-name">JUC</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/JVM/"><span class="card-category-list-name">JVM</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/javaweb/"><span class="card-category-list-name">javaweb</span><span class="card-category-list-count">3</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/SSM/"><span class="card-category-list-name">SSM</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/SpringBoot/"><span class="card-category-list-name">SpringBoot</span><span class="card-category-list-count">13</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/SpringBoot/API%E6%96%87%E6%A1%A3/"><span class="card-category-list-name">API文档</span><span class="card-category-list-count">2</span></a></li></ul></li>
          </ul></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/" title="查看更多"><i class="fas fa-angle-right"></i></a>
    </div>
    <ul class="card-archive-list">
  
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2023/04/">
          <span class="card-archive-list-date">四月 2023</span>
          <span class="card-archive-list-count">2</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2023/02/">
          <span class="card-archive-list-date">二月 2023</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2023/01/">
          <span class="card-archive-list-date">一月 2023</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2022/09/">
          <span class="card-archive-list-date">九月 2022</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2021/12/">
          <span class="card-archive-list-date">十二月 2021</span>
          <span class="card-archive-list-count">3</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2021/10/">
          <span class="card-archive-list-date">十月 2021</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2021/06/">
          <span class="card-archive-list-date">六月 2021</span>
          <span class="card-archive-list-count">3</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2021/05/">
          <span class="card-archive-list-date">五月 2021</span>
          <span class="card-archive-list-count">2</span>
        </a>
      </li>
    </ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">72</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-07-18T09:57:57.063Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div><div class="card-widget card-widget card-like" id="lovelygirl" style="order: -1"><div class="item-headline"><i></i><span></span></div><div class="item-content"><img width=100% height=100% src="https://img.yww52.com/lovely.jpg"/></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By yww</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="/live2d-models/index.min.js"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:false,parentElement:document.body,primaryColor:"#d0c3fc",sayHello:true,models:[{"path":["/live2d-models/慕鸾/86.model3.json","/live2d-models/慕鸾婚服/116.model3.json","/live2d-models/小天使/qc.model3.json"],"name":"慕鸾","position":[-70,0],"scale":0.09,"stageStyle":{"width":250,"height":250},"mobilePosition":[-10,23],"mobileScale":0.1,"mobileStageStyle":{"width":180,"height":166},"motionPreloadStrategy":"ALL"}],menus:{disable:false},tips:{style: {"width":200,"height":110,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:["你好呀~","欢迎来到我的小站~"]}},statusBar:{"disable":false}});</script><!-- hexo injector body_end end --></body></html>